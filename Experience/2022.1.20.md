## 云览科技
- 把类的构造函数定义为private或者protected，通常都有什么应用场景呢？
    - private只能被类中的成员访问。
    - protected只能被类及子类访问。
    - 定义为private是不想让外部创建对象。
    - 单例模式
- 把析构函数定义为private，一般有哪些用途，或者定义为private能不能创建对象呢？
    - 限定只能在栈上分配内存，禁止生成栈对象。因为栈对象离开作用域后会自动调用析构函数。
    - 用途：定义为private只能在类内部调用析构，或者是在调用析构前，完成指定的操作。
- shared_ptr是怎么实现的呢？两个线程同时对shared_ptr赋值是线程安全的吗？引用计数会不会出现内存泄漏，预期变成2，实际变成了1？
    - 循环引用问题。
- basic string和vector<char*>有什么区别呢？
    - typedef basic_string<char> string
    - string是通过basic_string来实现的，string是模板类basic_string的char特例化版本。
    - 两者在数据结构和内存管理方面都是相同，但是basic_string对字符串的操作做了一些扩展。
- C++17的variant和any有什么区别呢？
    - variant
    - any
- 怎么定位大段代码的性能瓶颈，如何定位到大段耗时？CPU很高如何定位？
- 如何定位程序中的死锁？
- 线程和协程有什么区别？
    - 线程：
    - 协程：轻量级线程。
- 实现一个线程池的思路？线程执行的结果怎么获取？
- 进程CPU跑的很高，如何定位后台服务的问题？

## basic_string类

- 类似于vector
- 三个指针：start  finish end_of_storage

## 2022.1.25字节跳动-成都-Windows/Mac C++开发

- 想自己创建一个对象作为map的key有什么限制？
    - 需要自己去实现散列函数。
- vector和list的差别和各自适用的场景？vector自动扩容是怎么扩的呢？
    - 自动扩容
    - 单链表
- move的定义，特性和适用场景？转移后继续使用原来的对象会出现什么问题？
    - 适用场景：return返回值
- 虚函数，析构函数为什么会定义成虚函数呢？析构时父子类调用顺序是什么样的？
- 一个class类，有两个虚函数，和一个成员变量，那么这个类的size是多大？
- 线程同步的方式有哪些？互斥锁mutex是可重入的吗？
  - 

- IPC通信有哪些？
    - 管道
    - 共享内存
    - 消息队列
    - 套接字
    - socket
- 管道分哪几种？在使用过程中如何防止管道阻塞？
    - fifo
    - pipe
- socket通信流程是什么样的？使用TCP和UDP有什么区别？
    - connect
    - listen
    - accept
- 数据库中有几种表连接的方式？连接的方式？
    - 左右连接

## variant

- 一个可以存储多种类型的容器，variant是类型安全的。提供了很多好用的函数，which()和get()。

## C++复习2022.4.9

- 多态原理
    - 基类指针或引用动态绑定到子类时，根据实例对象产生不同的行为。
    - 基于virtual和继承实现，是在运行时动态绑定。
    - 每个类有一个虚函数表。
    - 每个对象有一个虚函数表指针。
    - 虚函数表记录当前类及父类中的虚函数的实际地址。
- STL库
- 新特性
- 构造
- 析构
- 智能指针
- 操作系统
- 模板
- 面向对象
- 设计模式

## 西门子胡刚电话

- 在Linux上操作
    - Linux常用的命令
- 客户端的CPP开发
- 用git管理版本
    - git相关的面试问题
- 使用的软件clion/vscode/visual studio
- 时序图，UML建模、设计模式

## 计划

- 先把C++基础知识过一遍，牛客网做两套笔试题。
- 操作系统的知识过一遍。
- 把自我介绍和常用的交流口语准备好，背熟。
- 把演讲的PPT准备好。

## 知识点

- 重载，重写，隐藏
- 构造函数
- 析构函数
- new和malloc
    - 共同点：都是在堆上申请内存，进行动态内存分配。
    - new是操作符；malloc是库函数。
    - new申请空间，成功后返回该类型的指针；malloc返回void*，需要强制类型转换
    - new无需指定内存大小，malloc必须指定开辟内存的大小。
    - new可以初始化，malloc不可以初始化
    - new分配失败抛出bad_alloc异常，malloc分配失败返回NULL。
    - new是先申请内存，然后调用的构造函数吗？new Node(0) 好像是的。
- C++内存模型
- 模板
    - 编译相关的
    - 模板元编程

## 新知

- 多态
    - 虚函数表指针
- 重载
    - extern "C" 告诉编译器，这部分代码使用按照C语言语法编译，C是不支持重载函数，因为在汇编层面是按照函数名命名。
    - C++的重载将参数的类型添加到新的命名中，使重载函数可以按照参数列表的不同进行调用。
- 常量
    - #define: 字符串展开，不方便定位bug。同名常量可能覆盖。
    - const：namespace+const
    - constexpr
- 重复导入
    - pragma once 只导入头文件一次
- 智能指针
    - unique_ptr：独占，只有一个拥有者。最好用std::make_unique<User>()赋值，std::move(e1)转移拥有者给其他owner。
    - shared_ptr：共享，有多个拥有者。可以直接赋值，引用计数增加。
    - weak_ptr：通过shared_ptr赋值，在使用的时候必须转换为shared_ptr,对应的shared_ptr引用计数增加1，使用完成后恢复。通过weak_entity.lock()拿到对应的shered_ptr对象。没有ownership，或者只有临时的ownership。
    - 引用计数：变为0的时候，立马销毁。多线程使用shared_ptr。
    - 循环引用问题：weak_ptr辅助解决。
- 右值引用
    - 引用：pass by value/ reference
    - 左值
    - 右值
- 内存模型
    - 栈
    - 堆
- 引用和指针的区别
    - 引用
        - 引用本质上是指针
        - 不能为空
        - 不能指向其他对象

## 基本盘

- C++
    - 面向对象
        - 构造、析构
        - 继承、多态
    - 新特性
        - 智能指针
        - 右值引用
        - 移动语义
        - 完美转发
        - lambada表达式
    - STL容器
        - vector
        - list
        - set
        - map
        - deque
    - 并发编程
        - mutex
        - 互斥锁
    - 内存模型
        - 栈大小1M
- 操作系统
    - 死锁
    - 进程
    - 线程
    - 多路复用
    - 协程
    - 内存管理
- 计算机网络
    - TCP/UDP
    - HTTP
    - URL
- 设计模式
    - 单例
    - 工厂
    - 策略
- 数据结构与算法
    - 红黑树
    - 哈希表
    - 快速排序
    - 归并排序
    - KMP

## C++面试问题

- 重载
    - 同类中，同名函数，但是参数列表不同。
    - C有重载吗？
        - 没有add
    - 实现方式
        - 根据参数列表进行区分，参数类型，参数数量，参数的顺序。
        - 编译时进行了命名的重整，add(int a, int b)，__addii
- 重写
    - 具有继承关系的类，子类对父类的同名虚函数，除了函数体，其他的都要相同，进行定义新的行为。@override
- 隐藏
    - 子类和父类同名的函数，排除了虚函数。get()，不管参数列表是否相同，在子类中，都将父类的同名函数给屏蔽。
- 多态
    - 编译时多态，运行时多态。
    - 继承，虚函数。
        - 基类指针或者引用绑定到子类的实例，根据具体的实例对象，实现不同的行为。
        - 子类重写父类的虚函数，通过父类指针指向子类对象时，产生不同的行为叫做多态。
        - 同一个接口，不同的表现行为。
    - 多态的机制
        - 虚函数表指针vfptr：每个对象都有，通过指针去访问到虚函数表。offset偏移，重写虚函数之后，新的代码就会覆盖原来的行为。
        - 虚函数表：一个类共有的，多继承，多张表。函数指针数组。
- 构造
- 析构
- 智能指针
- 右值引用
- 移动语义
- 完美转发
- 强制类型转换
- new和malloc区别
- 指针和引用的区别
- 堆和栈的区别
- 进程、线程、协程
- 死锁和如何避免
- 深浅拷贝
- 栈溢出
- 内存溢出
- IO多路复用
- RAII
- 自旋锁
- 互斥锁
- new底层是怎么实现的
- 内核态和用户态
  - 

- 进程和线程同步方式
    - 进程：资源分配的基本单位。程序加载到内存的动态表现形式、执行过程。数据段，代码段，进程控制块。进程有独立的虚拟地址空间。
        - IPC进程通信方式：
            - **套接字socket**
                - **双缓冲区：读写分离。**
                - **server：**
                    - **socket()**
                    - **bind() **
                    - **listen() 监听文件描述符的上限**
                    - **accept() 接收请求**
                    - **recv()**
                    - **close()**
                - **client：**
                    - **socket()**
                    - **bind()**
                    - **connect()**
                    - **send()**
                    - **close()**
                - **TCP**
                    - **三次握手**
                    - **四次挥手**
                    - **拥塞控制**
                - **HTTP**
            - 管道
            - 共享内存
            - 消息队列
            - 信号量
            - 信号
    - 线程：
        - CPU调度的基本单位。进程可以包含多个线程，这些线程共享进程的资源。线程的粒度比进程更小。线程可以通过共享数据来实现通信。比进程的通信方式更方便。多线程的上下文切换开销比较小。保存寄存器的值，移动程序计数器PC，栈上的数据。
            - **线程独占的资源**：线程ID，**栈，寄存器，**线程优先级，信号屏蔽字。kill -9 PID
            - **线程共享的资源**：堆，全局区，打开的文件，文件描述符，进程的内存地址空间，全局变量，静态变量。信号的处理方式。
            - **同步方式**：互斥锁，读写锁，自旋锁，信号量，信号，条件变量。
        - **进程的上下文切换的开销**
            - 直接开销：熟悉页表全局目录，刷新寄存器的值，刷新TLB，切换内核态堆栈。
            - 从一个进程跳转到另一个进程进行执行。
            - 更换虚拟地址空间，重写加载。
            - 寄存器数据，地址空间，栈上数据保存。
            - 程序计数器。
            - 加载新数据到内存。
            - 缓存失效。缓存的空间局部性和时间局部性失效。
            - TLB快表失效。
- 内联函数和宏定义
    - 宏定义：预编译时处理，只进行文本替换，不加括号容易出错。
    - 内联函数：编译时处理，对类型进行检查，将函数体嵌入到调用的位置。优点：减少函数调用的开销，包括寄存器值的保存和实参的拷贝。缺点：增加函数的体积，可能导致cache装不下，减少了cache的命中率。inline只是一个请求，编译器可以拒绝。
- volatile
    - 告诉编译器不要做优化。
    - 操作该变量一定要从内存中取值。
- 如果子类在构造函数中调用了父类的虚函数会发生什么？

## 相关考题

- define和typedef的区别
- 类派生继承
- 函数指针
- 单例类作用
- 构造函数和重载=
- 大量数据小内存如何求平均数
- 工业4.0
- 软件工程和设计模式

## 项目问题

- 优点
- 缺点
- 匹配点

## new

- new底层调用new operator，是C++内建的，无法改变其行为。
- new
    - 分配内存
    - 调用构造
    - 返回指针
- operator new可以根据自己的内存策略去重载。
- 多态
    - 编译时多态：函数重载和模板
    - 运行时多态：虚表保存在.rdata中，只读数据段。
    - 多继承就会有多个虚函数表。
- 父类构造函数中是否可以调用虚函数？
    - 可以。但是会屏蔽多态机制，最终会把虚函数当做普通函数调用，而不会调用派生类中被重写的函数。
- 构造函数可以是虚函数吗？
    - 不可以。虚函数的目的是为了多态。子类并不继承父类的构造函数。
    - 构造函数是为对象分配内存，同时也分配虚函数表指针。虚表指针还未创建，无法从虚表中获取虚函数的真实地址。
- 静态函数可以是虚函数吗？
    - 不可以。静态函数不属于任何类对象。静态函数没有this指针，无法获得虚表指针，无法访问虚函数。
- 虚函数的安全性问题
    - 让父类指针访问子类的自有虚函数。
- 析构函数可以是虚函数吗？
    - 可以。动态绑定。
- 析构可以是纯虚函数。
- 默认成员函数。
    - 构造
    - 析构
    - 拷贝构造
    - 移动构造
    - 赋值构造
    - 移动赋值