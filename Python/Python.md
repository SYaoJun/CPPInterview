# Python
## 保留小数
```shell
print("{:.2f} hello world!".format(3.1415))
```
## 可变参数
```python
*args 可变元组参数
**kwargs 可变字典参数
```
- 如果在接收的內部还需要将这些参数传递到其他函数需要拆包，即加上星号*args **kwargs

## python 2.x 和 3.x的区别

1.  print函数：2.x中为class不用加小括号，3.x中print为一个函数，必须加小括号。
2.  用户输入：2.x中用raw_input() 3.x中用input() 接收的都是字符串
3.  除法: 2.x中斜杠在分子分母都是整数是得到整除，有小数时才是浮点数除法， 3.x斜杠都是浮点数除法。

## GIL

全局解释器锁，每个线程在执行的过程都需要先获取GIL，**保证同一个时刻只有一个线程可以执行代码。**

线程在IO操作等可能引起阻塞的系统调用之前，可以暂时释放GIL，但在执行完毕后，必须重新获取GIL. python3使用计时器，达到阈值值后线程释放GIL。

htop和top

## 可变与不可变

可变与不可变是指内存中那块内容是否可以被改变

1.  可变：**列表 字典** 创建后可继续修改对象的内容

2.  不可变：**数字 字符串 元组**  一旦创建就不可改变的对象

## 深浅拷贝

copy.copy()浅拷贝

copy.deepcopy()深拷贝

python中一般的赋值都是引用拷贝，即浅拷贝。浅拷贝拷不动不可变类型，如元组，仅仅是指向。

如果用copy.copy 和copy.deepcopy对一个全部都是不可变类型的数据进行拷贝，那么它们结果相同，都是引用指引。

如果拷贝的是一个拥有可变类型的数据那么即使元组是最顶层，那么deepcopy是深拷贝，儿copy.copy还是指向。

## 私有化

变量前两个下划线__x 私有的

变量前后都有两个下划线 公有的 魔法方法

## 多态

子类重写父类同名函数，调用的时候直接调用子类重写的代码，如果继承后不重写调用的就是原父类的代码。

多继承时，使用super来调用父类的init函数，调用的顺序时根据mro函数中的元组顺序执行的，保证每个父类只被调用一次。

## 生成器

使用小括号的列表推导式和含有yield关键字的函数

## 协程

用户态的轻量级线程

## python内存管理机制

[视频](https://www.bilibili.com/video/BV1bJ411B7cZ?from=search&seid=731223436955367990)

python由C开发，源码重要的文件include和objects

python在创建对象时，会在内存多创建一些内容，包括对象的类型，引用计数器和双向链表。当赋值或者传参时引用计数加1，当delete时计数减1，当减为0后视为垃圾进行回收。

1.  引用计数：每个对象被引用一次就加1。
2.  [垃圾回收](https://www.bilibili.com/video/BV1T7411F7Wg?from=search&seid=731223436955367990)：针对容器对象使用一个双向链表收集起来，然后对每个引用找到它指向的对象，将这个对象计数减1，遍历完后，所有引用计数为0的，就是循环引用的对象。

## numpy和list的区别

1.  numpy array是**内存中的一个连续块**，并且array中的元素都是同一类型如浮点型。所以一旦确定了一个array它的内存就确定了。numpy array包含丰富的函数，运行速度快。
2.  list的每个元素是一个地址的引用，这个地址地址又指向了另一个元素，这些元素在内存中不一定是连续的。

