# Basic C++

### 推荐书籍

-   《C++ primer》 第五版
-   《后台开发》 徐晓鑫
-   《linux高性能服务器编程》 游双
-   《redis设计与实现》黄健宏
-   《muduo库》陈硕

### static

static的使用可以分为两类，一类是用在**普通变量和函数**上，另一类是**用在类中**。

1.  普通变量分为**全局变量和局部变量**。声明为静态全局变量是在**全局区分配内存**，并且**只在当前文件可见**，在文件之外是不可见的。其他文件定义同名变量不会发生冲突。变量的值**只在第一次执行时进行初始化**。声明为静态局部变量时与全局变量类似，只是**作用域为局部作用域**。
2.  静态普通函数，只在当前文件中可见，其他文件中定义同名函数不会发生冲突。
3.  static用在类中，首先是静态成员变量，**在类中声明，类外初始化。**所有对象共享一份数据。
4.  然后是静态成员函数：所有对象共享同一个函数，静态成员函数只能访问静态成员变量。



### 多态

多态分类两大类：静态多态和动态多态。静态多态是重载和模板。动态多态：也叫运行时多态，是通过**继承和虚函数**实现的。在具有继承关系的子类中，子类重写父类的虚函数，通过父类引用或指针指向子类对象时，产生不同的行为叫做多态。

多态的核心在于**虚函数表指针**，每个对象都有一个虚函数表指针，虚函数表指针指向一张虚函数表，表中记录了虚函数的入口地址，如果子类重写虚函数后，这个地址就会替换掉。**多态的好处在于更方便程序的扩展，坏处在于每个对象多了一个4字节的指针，同时每次查询虚函数表需要耗时。**

## 智能指针

C++11有3个智能指针，分别是**unique_ptr, shared_ptr和weak_ptr**

1.  unique_ptr独享指针的所有权，**无法进行拷贝构造赋值的操作**，**只能通过move函数进行所有权的转换。**
2.  shared_ptr共享对象，它使用引用计数来保存当前有多少个智能指针在引用这个对象，当引用计数降为0时，对象会被销毁。
3.  weak_ptr称为**弱引用**，用于辅助shared_ptr正常工作，主要解决shared_ptr可能会产生的**环形引用问题**。weak_ptr不会增加对象的**引用计数**，共享指针可以直接赋值给弱指针，同时弱指针可以使用lock函数来获取shared_ptr对象



## malloc和new

malloc和new都是在堆上开辟内存，进行动态的管理。

1.  new是操作符，malloc是库函数
2.  malloc只负责开辟内存，没有初始化功能。new不但能开辟内存，还可以初始化。
3.  malloc必须指定开辟内存的大小，并且返回类型为void*，因此malloc的返回值一般都需要进行类型转换。new可以自动计算出所需内存的大小，并且返回指定类型的指针。
4.  malloc和new如果操作是内置数据类型两者基本类似，不同在于申请失败时。malloc申请失败时返回**NULL。**new申请失败抛出异常。
5.  自定义类型时，new先调用**operator new**函数申请空间，然后在申请的空间上执行**构造函数**。

## C++内存模型

从高地址到低地址

1.  环境变量和命令行参数
2.  栈区
3.  共享区
4.  堆区
5.  未初始化数据段.bss
6.  初始化数据段.data
7.  代码段.text

## 指针和引用的区别

1.  指针保存的是**所指对象的地址**，而引用是所指对象的别名。指针需要通过解引用间接访问对象的值，引用可以直接访问。
2.  指针可以有多级指针，而引用最多两级。并且**两个取地址符是右值引用。右值引用是为了减少深拷贝的次数。**
3.  指针可以不初始化，即使初始化以后也可以改变。而引用必须初始化，同时初始化以后不许改变。
4.  **引用的本质是指针常量**。指针常量不可以修改指向，但是可以修改指向的值。常量指针刚好与之相反。



## vector底层原理

首先，vector的基类是三根指针，分别是start/finish/end_of_storage用来指示当前分配到的空间所用的起始位置，终止位置和容量尾部。然后，当finish指针到达end_of_storage的位置时，操作系统会寻找当前容量大小2倍的连续内存空间，并且将旧内存中的数据拷贝到新内存，然后释放旧内存。其次，如果重新分配了内存，原来的迭代器就会失效。频繁的开辟新内存比较耗时。如果可以预知使用的大小，可以使用reserve函数，预先开辟足够大的空间。或者使用swap函数收缩内存空间。



## 代码生成可执行文件的过程

主要分为四个步骤

1.  预编译阶段：对g++编译器指定-E参数，生成.i文件。这个阶段的主要工作是将所有的宏展开，去掉所有的条件预编译指令，将所有的头文件包含进来，删除注释等。
2.  编译阶段：对g++编译器指定-S参数，生成.s汇编文件。这个阶段的主要工作是对代码的语法，语义和词法等进行分析。
3.  汇编阶段: 对g++编译器指定-c参数，生成.o二进制文件。
4.  链接阶段：将各个模块之间的相互引用处理好。把所有的静态库用到的目标文件装入程序中，并进行统一编址，然后进行重定位，即逻辑地址到物理地址的转换。



## 静态库与动态库

1.  静态库：命名方式为lib开头加上自定义的静态库名，然后以.a结尾。静态库实际上是一组目标文件的集合，再链接阶段与调用的程序生成可执行文件。静态库的优点在于：**代码加载速度快，发布程序时，不需要提供对应的库；**缺点时：可执行文件体积大，**同时如果静态库有修改，调用的程序需要重新编译，**而编译的耗时比较久。 
2.  动态库：命名方式为lib开头加上自定义的动态库名，然后以.so结尾。**动态库首先生成与位置无关的目标文件**，然后再运行时加载到内存。优点是：**动态库可以共享，节省了系统资源**，动态库进行修改后，无需重新编译。缺点是加载速度比静态链接慢，发布程序时，需要提供动态库。



## 符号表

每个目标文件除了拥有自己的数据和二进制代码外，还提供了3个表：

1.  未解决符号表：提供了所有在该编译单元里引用但是定义并不是在本编译单元的符号及其出现的地址。【引用无定义】将extern声明的变量置入未解决符号表。【外部链接】
2.  导出符号表：提供了本编译单元具有定义，并且愿意提供给其他单元使用的符号及地址。【有定义肯让外用】普通变量及其函数被置入导出符号表。
3.  地址重定向表：提供了本编译单元所有对自身地址的引用的记录。**static声明的全局变量放入地址重定位表中**。【内部链接】

## 指针常量

```c
int* const p = &a
```

**指针常量必须初始化**，一旦初始化完成，就不能再修改它的值，即指针的指向不可变。

引用的本质是指针常量

## 声明和定义的区别

1.  声明是告诉**编译器**有这个**变量和函数的存在**，但是需要到其它地方去寻找。
2.  定义包含了声明，但是声明不包含定义。
3.  **定义时才分配存储空间。**

## C和C++的区别

1.  设计思想上： C是面向过程的结构化语言，CPP是面向对象的语言 
2.  语法上： CPP具有三大特性，**封装继承多态** CPP相对于C增加了许多类型安全的功能，比如四种强制类型转换 CPP支持范式编程，如模板类，函数模板等

## struct和class的区别

1.  共同点：**C++中，可以用struct和class定义类，都可以继承。**

2.  不同点：struct默认继承权限和默认访问权限时public class类的默认继承权限和访问权限时private。

## volatile关键字

对类型额外修饰的作用，类似于const。**告诉编译器不要对这样的对象进行优化**，因为该对象的值可能在程序的控制或检测之外被改变。

## const关键字

const 可以用于限定**变量，指针和函数**不可改变，同时明确制定了类型，可以方便编译器做类型检查，也增加了代码的可读性。

1.  const修饰变量必须初始化。如果是全局的const变量，通常放在静态区。**在局部声明的const变量放在栈区。**

2.  const修饰成员函数时，函数中的成员变量不可改变，除非该变量特别声明为mutable

3.  const可以用来修饰指针，称为常量指针const int *p 指针的指向可以改变，但是不能改变指针指向的值。

4.  const修饰常量的指针叫做指针常量，int* const p 指针的指向不可以修改，指针指向的值可以修改。指针常量必须初始化。

**const可以明确指定类型，而宏定义没有数据类型。**

**define宏是在预处理阶段展开。const常量是编译运行阶段使用。**

**宏定义不分配内存，变量定义分配内存。**



## extern关键字

1.  引入同一模块在其他文件中定义的**全局变量和函数**。
2.  如果在C++里调用了C库定义函数，那么需要使用`extern "C"` 标识这个函数，告诉编译器使用C的方式进行编译，防止C++的编译方式导致命名重整，无法找到对应的C函数。命名重整的原因在于**C++支持函数重载，而C不支持。**所以C++编译时增加了函数参数的标识符。
3.  extern通常放在为解决符号表中，表示定义不在本文件而引用的变量。

## this关键字

1.  解决同名冲突
2.  返回对象本身

this指针的本质是**指针常量**，指针的指向不可以修改。

## move函数

**将左值强制转换为右值引用**，右值引用可以减少一次对象的析构和对象的构造。

**右值引用可以减少深拷贝的次数。**

## 段错误

段错误通常发生在访问非法内存地址的时候。系统会发送一个SIGSEGV11号信号告诉当前进程，进程采取默认的捕获方式，即终止进程。

1.  野指针
2.  试图修改字符串常量的内容

## auto关键字

让编译器能够根据初始值的类型推断变量的类型。当处理复杂类型，比如STL中的类型时，优势最明显。`auto p = vt.begin()`

## 四种强制类型转换

1.  **static_cast 低风险的转换，比如整数转浮点数，字符型转整形**
2.  **const_cast 去掉const关键字的转换，可以去掉带const的指针和引用**
3.  **dynamic_cast  使具有继承关系的基类转换为派生类，如果不可以转换则返回NULL**
4.  **reinterpret_cast 指针或引用的转换，风险较高**



## RTTI

run time type identification 运行时类型识别。**常常结合typeid()和dynamic_cast实现。**可以根据当前调用的指针是何种类型，经过dynamic_cast转换后，调用非虚函数。**dynamic_cast只能用于指针和引用的转换，要转换的类型中必须包含虚函数，转换成功返回子类的地址，失败返回NULL。**typeid返回一个type_info对象的引用。



## 构造函数不能是虚函数

虚函数是通过虚函数表指针来调用的，而虚函数表指针存在对象内存空间。当一个对象调用构造函数时，该对象还没有实例化，即没有分配内存空间，所以虚函数表指针无法找到。



## 析构函数尽量是虚函数

析构函数不是虚函数容易引起**内存泄漏**。

为了实现多态的动态绑定，通常将基类指针指向派生类对象，当指针销毁时，如果析构函数不是虚函数，根据析构函数在继承中的调用顺序，则派生类对象将不会被析构，造成内存泄漏。



## 析构函数不能抛出异常

析构函数抛异常，则异常点之后的的程序不会执行，如果异常点之后有释放资源的操作，则这部分资源无法释放，导致内存泄漏。**noexcept**



## 内存泄漏

不再需要使用的内存单元，没有及时释放。memcheck和valgrind检测内存泄漏的工具。使用RAII资源获取就是初始化和智能指针。



## 野指针

一些内存的单元已被释放，之前指向它的指针还在被使用。



## vector和list的区别

1.  vector是动态数组，在内存中分配一块连续的内存空间，因此可以使用下标进行快速的随机访问。但是删除和插入需要移动大量的元素。
2.  list是双向链表，在内存中是不连续的空间，由指针将不同的地址连接在一起。list的插入和删除操作都是O(1)的。
3.  数组必须事先设定固定的长度，不能动态的增减，可能会造成资源浪费。链表可以动态的增减。



## 浅拷贝

由于编译器默认的拷贝构造函数只是简单的位拷贝，可能会导致内存的重复释放。解决浅拷贝的办法通常使用深拷贝，即自己实现拷贝构造函数，在堆上重新分配内存。

## 内存对齐

union最大成员所占的整数倍，同时能容纳其他的成员。union中变量共用内存，应以最长的为准。	

struct按照成员的声明顺序，依次安排内存，偏移量为成员大小的整数倍，最后结构体的大小为最大成员所占大小的整数倍。在C++中，空结构体和空类的内存所占大小为1个字节。C中空结构体所占大小为0。

为什么要有内存对齐：1. 硬件原因：**加速CPU的访问速度。**因为CPU和内存数据交换的基本单位是块，块的大小为2的n次方字节。内存未对齐可能需要多次访问内存。2. 平台原因：**不是所有的平台都支持任意地址的数据访问。**

```c
#include <iostream>
using namespace std;
typedef union{
	long long i; //8 bytes 
	int k[5]; //4 bytes 最长的成员不是20  
	char c; // 1 byte 
}UDATE;
//联合体共用内存 最长成员为8字节 结果要为8的倍数 同时要能容纳其他成员，即大于等于20字节 所以为24字节 
struct data{
	int cat; // 4 bytes
	UDATE cow; //24 bytes 但是需要先拆开来 最长成员为8字节 
	double dog; //8 bytes 
}too;
//结构体顺序考虑，结果为最大成员的整数倍，如果后一个成员的长度的开始位置不是整数倍需要填充字节
//cat占4个字节 填充4个字节 
//起始位置为8 满足整数倍 cow占用24字节
//起始位置为32 满足整数倍 doule占用4字节
//所以结构体总共占用40字节，同时40也是8的倍数。 
UDATE temp;
int main(){
	cout<<sizeof(temp)<<" "<< sizeof(struct data)<<endl; //24 40 
	return 0;
} 
```

## gdb调试

gdb可以用于分析coredump文件，coredump文件中含有当进程被终止时内存，cpu寄存器和各种函数堆栈信息等。

1. 设置断点 b 120
2. 运行 r 
3. 打印遍历p  number
4. 查看堆栈bt
5. 查看循环中的变量 i
6. 单步运行n
## volatile

用来告诉编译器不要对该变量做任何优化，编译器每次操作该变量时，一定要从内存中取出，而不是使用寄存器中与存在的值，因为值可能已经发生了改变。

应用场景：

1.  并行设备的硬件寄存器（如状态寄存器）。
2.  多线程中共享变量。

## const

用于限定变量，函数和指针不可改变。

1.  const限定全局变量时，变量放在静态区。const限定局部变量时，变量放在栈区。
2.  const修饰类中的成员函数时，表示不可对类的对象更改，如果需要更改类中的成员变量，可以使用mutable关键字。

## 内联函数和宏定义

1.  宏定义在预编译时展开，内联函数在编译时展开。
2.  宏定义只是简单的文本替换，不进行参数的有效性检查。内联函数会进行类型检查，然后将函数体嵌入到目标代码中。
3.  宏定义不加括号容易出错。内联函数没有普通函数的栈操作，效率很高，但是不正确的时候内联函数会导致代码体积过大。



## static

静态全局变量，静态局部变量，静态成员变量，静态成员函数

1.  静态全局变量和静态局部变量都放在静态区，只在声明时初始化一次，仅在本文件中可见，变量在程序运行期间一直存在。静态局部变量的作用域范围仅在局部，下次调用紧接着上次调用的结果值改变。
2.  静态成员函数和静态成员变量没有this指针，必须通过类名才能访问。

## malloc 和 new

1.  malloc和free是库函数，new和delete是运算符，可以重载。
2.  malloc申请内存时需要指定内存大小，返回一个void*类型，通常需要强转。new申请内存时无需指定内存大小，返回一个对应类型的指针。
3.  malloc不进行初始化。new在创建非内部类型的对象时，调用构造函数初始化，消亡时会调用析构函数。
4.  malloc申请失败时返回null指针，new申请失败时抛出异常。

## 指针和引用

1.  引用创建时必须初始化，初始化后不可以改变。指针创建时可以不初始化，初始化时需要分配内存，初始化后也可以改变。引用比指针安全。
2.  引用不存在空值引用，指针可以指向空值
3.  引用的本质是指针常量，由编译器完成转换。

## extern

1.  可以被其他源文件调用。
2.  告诉编译器，extern限定的代码使用C语言的编译和连接方式。因为C++支持重载，而C不支持，所以可能导致函数编译后的名称不一致，从而找不到对应的函数。

## 多态的原理

多态分为静态多态和动态多态。静态多态是通过重载和模板实现的，动态多态是通过继承和虚函数实现的。

动态多态是让基类的指针或引用指向派生类的对象实现的。定义为虚函数的基类，编译器会自动创建一个虚函数表，派生类在继承时会继承这个虚函数表，每个创建的对象拥有一个虚函数表指针，这个指针指向虚函数表，如果派生类重写了基类的虚函数，则对应的虚函数表入口地址发生了更新。虚函数表为所有对象所共享，通常放在代码段。

## 什么是进程

进程是分配资源的基本单位，是程序运行的实例。进程通常分为数据段，代码段和进程控制块。进程的地址空间相互独立，一个进程不可访问另一个进程的数据。进程切换时的开销相对于线程来说比较大，需要保存寄存器的值和刷新块表，切换地址空间等。

## 进程间的通信方式

1.  有名管道pipe
2.  无名管道fifo
3.  消息队列
4.  共享内存
5.  信号量
6.  信号
7.  套接字

## 线程是什么

线程是CPU调度的基本单位。线程是进程的一个执行流程。一个进程中可以由多个线程。线程共享进程的地址空间。线程自身几乎不拥有系统资源，除了栈和寄存器。线程间的通信较为容易。但是需要同步。常用的同步机制有互斥锁，读写锁，信号量，条件变量。

## 线程共享

1.  进程打开的文件描述符表
2.  进程ID和组ID
3.  信号的处理方式
4.  打开的工作目录
5.  进程的地址空间(堆区，栈区，共享区)

## 线程独享

1.  线程ID
2.  线程的寄存器
3.  线程的栈
4.  信号屏蔽字
5.  线程优先级
6.  错误返回码errno

## 信号

信号是一种不精确的通信方式。常用的信号有15号信号，杀死进程 29号进程 11号段错误

## http和https的区别

https是安全版的http协议。

## get和post的区别

get用来获取资源，post用来创建资源。

get将数据放在url地址栏中，使用问号与url分割，数据间用取地址符分割。post将数据放在请求体中。

安全性上get放在url容易暴露隐私信息，而post放在请求体中可以适当的避免。

get在传输的数据受url地址栏的限制，post不受这种限制

get的操作是幂等的，多次操作产生的影响相同，而post是非幂等的

## B树和B+树的区别

B树是多叉平衡树，**M阶的B树，每个节点最多有M-1个关键字，**每个节点的关键字都按照从小到大的顺序排列，因此查询时可以使用二分查找法。

**B树中所有叶子节点都位于同一层，每个节点都存有索引和数据。**

**B树的优点在于查询单个数据时，由于每个key都存有对应的date，查询到后可以直接取回。**

B+树非叶子节点只存索引不存数据，每个叶子节点增加一个指向相邻接叶子节点的指针，所有的节点都存在叶子节点。B+树的优点在于范围查询时，可以利用相邻的指针获得指定范围内的数据。

## 网络拥塞

1.  慢启动
2.  拥塞避免
3.  快速重传
4.  快恢复

## TCP和udp的区别

tcp面向连接的可靠的流式协议，具有超时重传和确认等机制。

udp面向无连接的报文协议，发出去就不管了，收则全收，丢则全丢。

## 智能指针

unique_ptr

shared_ptr

weak_ptr

## 四种强制类型转换

const_cast去掉const属性的转换，包括const指针和引用

static_cast用于低风险的转换，比如字符型转整形

dynamic_cast 用于具有继承关系的派生类和子类的转换，当基类转为子类时，如果转换失败会返回NULL

reinterpret_cast 任何类型都能转，风险较高

## post和put的区别

post用来创建资源，put用来更新资源

post是非幂等的，put是幂等的。

8中请求方法：

http 1.0: get post head

http 1.1: put delete options connect trace

## mmu内存管理器

主要作用：虚拟内存到物理内存的地址映射。 设置修改内存访问级别。

## 虚拟内存的作用

1.   解决主存容量有限
2.  分隔进程，保证进程空间彼此独立不受干扰
3.  基于局部性原理进行页面替换

虚拟内存的大小由计算机的地址总线决定

cache名字和TLB命中没有必然联系，是两种独立的机制。

CPU和Cache之间交换的单位是字节，Cache和内存之间交换的单位是块。

## coredump文件

gdb可以用于分析coredump文件。coredump文件含有进程被终止时内存/CPU寄存器和各种函数调用栈的信息。

产生coredump文件的原因：

1.  内存访问越界
2.  多线程使用了线程不安全的函数
3.  多线程读写的数据未加锁保护
4.  栈溢出

core文件没有符号表信息，必须结合可执行文件才可调试

## 模板特化

全特化：模板参数被指定未确定的类型

偏特化：模板参数没有被全部确定，需要编译器在编译时进行确定。只能偏特化类模板，不能偏特化函数模板。

别名模板和变量模板属于语法糖

## 元编程

在**编译时**计算出**运行时**需要的常数，类型和代码的方法。

## 右值引用

右值引用指向要被销毁的对象。右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

move函数将左值转换为右值，调用move函数后源对象只能赋值或销毁。

## override

override在子类中标记某个函数，表示想要覆盖已有的虚函数，如果没有覆盖，编译器会报错。

加作用域运算符调用特定类的虚函数

## 内联函数的优劣

1.  优点：减少函数调用的开销，包括寄存器值的保存和实参的拷贝等。
2.  缺点：增加函数体积，可能导致cache装不下，从而减少了cache的命中率。

inline只是一个请求，编译器有权拒绝。

## 拷贝构造函数

调用场景：

1.  一个对象以值传递传参
2.  一个对象以值传递的方式从函数返回
3.  一个对象通过另一个对象初始化

## 空类

占有一个字节

有构造，析构，拷贝，赋值运算符，取地址运算符。

构造函数可以被重载，析构函数不可以被重载且不能带参数。

## explicit

explicit取消隐式转换，类中构造函数默认是implicit

explicit关键字的作用是防止类构造哈桑农户的隐式自动转换，只对有一个参数的构造函数有效。

## 堆和栈的区别

1.  申请方式不同。栈由操作系统自动分配，堆需要程序员自己申请。
2.  生长方向不同。栈由高地址向地址生长，是一块连续的内存区域。堆由地址向高地址生长，是不连续的内存区域。在一个链表中记录空间内存地址。
3.  分配速度。栈由系统分配，速度较快。堆使用new分配，速度较慢，且容易产生内部碎片。



## C++ 和python的区别

python是解析性语言，无需编译，方便快捷，跨平台性很好。

C++是编译型语言，先编译后执行，编译后通常不能跨平台。

python使用严格的缩进来表示不同级别的代码块，在C++中使用花括号。

## 索引

select语句调用函数后就不会用到索引

## static的作用

static可以用来修饰函数和变量。修饰全局变量和局部变量时都是放在静态区，static变量只初始化一次，在程序结束时销毁，全局和局部的区别在于作用域不同。static可以修饰普通成员函数，表明这个函数只在本文件中有效。static修饰类成员变量是，这些变量为这个类所共享，static修饰类成员函数时，也是所有对象共享这个函数，该函数中没有this指针。同时static类成员函数中只能调用static修饰的函数。

## 静态存储区

1.  存放的static修饰的全局变量和局部变量，const修饰的变量以及字符串。

## 数据段和静态区的区别

数据段存放的是代码的二进制指令。静态区是变量。

## 虚函数的实现机制

每个含有虚函数的类都有一个虚函数表，类创建的对象都由编译器自动生成一个虚函数表指针来指向虚函数表。子类继承时会继承这个虚函数表，在子类中如果重写了父类定义的虚函数，这个虚函数中的对应内容会替换为重写的内容。当父类指针或引用指向子类对象时，调用对用对应的虚函数时会根据虚函数表指针找到虚函数表，然后从表中找到重写的虚函数入口地址，然后实现对应的行为。虚函数使代码更具有扩展性。

## python的多态

子类继承父类，子类重写父类的函数，调用时就自动调用了子类的函数。

## C++和python的区别

1.  C++是编译型语言，需要先编译再执行，编译后通常不可以跨平台。
2.  python是解释型语言，直接运行，跨平台好。上手快，容易浮于表面不够深入。

## python带来的收益

快速上手机器学习和深度学习，直接调用大量的库函数。

## STL底层容器和实现原理

1.  vector是动态数组，分配连续的内存，2倍扩容。
2.  list双向表，插入删除效率高。
3.  map和set红黑树，有序的容器。
4.  stack和queue底层可能都是数组实现
5.  unordered_map和unordered_set哈希表。
6.  array栈上分配的数组执行效率快。
7.  tuple元组多数据类型的集合。

## 快排

基于交换和分治的算法， 平均nlogn 最坏n平方

## 四次挥手

主动关闭方发送FIN标志位，自身状态进入FIN_WAIT_1被动关闭方收到FIN后，发送ACK确认，自身进入CLOSE_WAIT状态，当主动关闭方收到ACK后，进入FIN_WAIT_2状态，此时主动关闭方只能接收数据，不能发送数据，因为TCP是全双工的，所以要等待被动关闭方关闭后才结束。此时进行了两次挥手，双方进入半关闭状态。当被动关闭方需要关闭时，发送FIN标志位，发出后自身状态进入LAST_ACK状态，如果对方收到FIN标志位后，发送ACK应答，自身进入TIME_WAIT状态，等待2MSL后关闭连接。等待的2MSL是报文在网络传输中一个来回的长度。确保最后一个ACK能被对方收到。

## static关键字

static可以修饰普通函数变量和类成员函数和变量。

1.  static修饰普通变量时，分为全局变量和局部变量，两者都保存在静态区，并且只初始化一次，在整个程序运行期间一直存在。全局变量和局部变量的区别是作用域不同。
2.  static修饰普通函数时，说明此函数只在本文件中可见，防止多个文件的同名冲突。
3.  static修饰类中的成员变量时，必须在类中声明，在类外初始化，初始化的时候分配内存，所有的static成员变量为所有对象共享。
4.  static修饰类中的成员函数时，只能调用static的变量和函数，没有this指针，所有对象共享这个函数，可以使用类名直接调用。



变量分为全局变量和局部变量，static修饰全局变量时，表示这个变量只在本文件中可见

## const关键字

const用于限定变量指针和函数不可改变，方便编译器做类型检查。

1.  cons修饰**变量**时必须初始化。const全局变量通常放在静态区，const局部变量放在栈区。
2.  cosnt修饰**成员函数**时，函数中的成员变量不可更改，如果要修改成员变量需要声明为mutable
3.  const修饰**指针**有两种，常量指针和指针常量，常量指针是指针的指向的值不可改变，而指针的指向可以改变。指针常量是指向不可变，而值可变。

## const和define的区别

1.  const明确指定类型，编译器对类型做检查，而define没有类型也不 检查。
2.  const分配内存，而define不分配。
3.  const在编译期处理，而define在预编译期进行宏替换。define的宏替换不加括号会产生严重的影响。

## 指针和引用的区别

1.  指针保存的是所指对象的地址，而引用是所指对象的别名。指针通过解引用间接访问所指的对象，而引用直接访问。
2.  指针可以有多级，而引用最多两级。当有两个取地址符时，是右值引用，右值引用可以减少深拷贝的次数。
3.  指针定义时可以不初始化，即使初始化后也可以改变。而引用定义时必须初始化，初始化后不可以改变。
4.  引用的本质是指针常量，编译器帮助转换。指针常量的指向不可以改变，值可以变。

## define与内联函数的区别

1.  内联函数是一个函数，在编译期插入到调用的地方，而define在预处理期进行替换。
2.  内联函数避免了函数调用时的压栈和参数拷贝等操作，提高了性能。
3.  内联函数对参数有类型检查。define不加括号容易出错。

## new和malloc的区别

1.  malloc是库函数，new是运算符
2.  malloc只分配内存不初始化，而new不仅分配内存也初始化。new分配内存以后自动调用构造函数。
3.  malloc分配内存时必须指定内存大小，而new可以自动计算。malloc分配完成后返回的是void*类型，需要强转，而new返回的是对应类型的指针。
4.  malloc分配内存失败时返回NULL，而new分配内存失败时抛出bad_alloc异常。

## http和https的区别

两者都是用于客户端和服务器端通信。

https是http的安全版。

主要区别在于：

1.  http是明文传输，https是密文传输。
2.  http默认端口是80， https的默认443
3.  https需要验证服务器端的身份，如果CA证书不正确则会中断通信。
4.  CA证书需要成本，加密解密的过程增加CPU和内存的开销。

https增加了ssl层，用于确保传输的安全性。

通信前先进行ssl层的握手，首先客户端ssl版本号和加密组件发送给服务器端。

服务器端筛选出可用的ssl版本号和加密算法同时加上CA证书发送给客户端。

客户端验证CA证书的有效性，如果无效则中断通信。

若有效客户端发送加密的pre-master secret随机密码串，这一步使用的是非对称加密，用于协商后面对称加密的密钥，所以这一步不能被篡改和截获。客户端得到服务器端的响应后，且验证通过后，后续就使用对称加密加密算法进行加密。然后进行TCP三次握手。

## http1.0和http1.1的区别

http1.0只支持短连接，即一次通信完成后就立即断开

http1.1支持长连接，一次TCP建立以后，可以进行多次请求。

http1.0只提供了三种请求方法：get post head

http1.1增加了五种请求方法：put delete connect trace options

http1.1增加了许多状态码，比如100 continue 表示已经收到，等待后续的资源。206 partial content 部分资源

http1.1支持一个物理主机上可以有多个虚拟主机共用一个IP
## 最左前缀法则（理解成爬楼梯）

[视频辅助](https://www.bilibili.com/video/BV1zJ411M7TB?p=55)

sql查询条件中需要包含复合索引中的最左列，不能跳跃索引，否则索引失效。查询条件在where中出现的顺序没关系，只要按照最左前缀原则出现了，就会走索引。如果跳跃了索引，查询条件中满足最左前缀的部分走索引，到跳跃的部分时索引失效。

## 索引失效

1.  范围查询后其右边的列，索引失效。即索引某个字段使用了范围查询，他右边的索引将不再走索引。
2.  在索引列上进行运算操作，索引失效。（子串匹配查询）
3.  字符串不加单引号，索引失效。
4.  用or分割的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。
5.  以%开头的like模糊查询，索引失效。
6.  如果mysql评估全表扫描更快，索引失效。
7.  is NULL, is NOT NULL, 有时索引失效。
8.  in走索引，而not in索引失效。

## 优化

1.  使用索引。
2.  根据sql实际解析的顺序，调整索引的顺序。
3.  **尽量使用覆盖索引，避免select *。**覆盖索引是指只出现在索引中的字段。
4.  尽量使用复合索引，而少使用单列索引。
5.  优化insert。一次插入多条数据。事务改为手动提交，分段提交。按主键顺序插入。
6.  优化order by尽量使用using index 而避免使用filesort

## 定位低效sql语句

1.  explain分析执行计划（索引失效或者关联查询太多join）
2.  慢查询日志
3.  show profiles

## mysql分库分表

[视频辅助](https://www.bilibili.com/video/BV1bE411d7FF?p=14)

主从集群也就是读写分离，读写分离只是分担了访问的压力，存储的压力并没有解决。数据库集群环境后都是多台slave，基本满足了读取操作，但是频繁写入堆master性能影响比较大，这个时候，单库并不能解决大规模并发写入的问题。

分库分表带来的问题：**1. 联合查询问题，join不再适用。2.事务问题，变成了分布式事务。好处：减少大量数据写入时锁对查询的影响。**按照存储类别分：用户库，业务库，内存库，图片库，日志库，统计库。

分表：垂直分表和水平分表。解决单张表记录太多的问题。切分策略和导航路由。单表的容量超过500W时建议水平拆分。不到最后一步，不要轻易进行水平分表。

开源方案：1. msyql fabric 2.atlas 3.TDDL 4.mysql proxy 小巧精干，能力有限。+ master/slave 构成一个简单版的读写分离和负载均衡。

主从复制，读写分离---> 垂直分库(每个库可以带slave)--->分区---->水平分表。中间各种通信，调度，维护和编码要求更高。

## 主从复制

一主多从。mysql复制是异步并串行化的。原理：slave从master读取binlog进行数据同步。主要分为3步：

1.  master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件binary log events。
2.  slave从master的binary log events拷贝到它的中继日志relay log
3.  重做中继日志中的事件，将改变应用到自己的数据库中。

## 锁机制

锁可以对有限的资源进行保护，解决隔离和并发的矛盾。通过锁机制可以实现事务的隔离性要求，使得事务可以并发地工作。

按操作分：读锁（共享锁） 写锁（排他锁）

按粒度分：行锁（偏写）表锁（偏读）

锁使用的考虑点：开销，加锁速度，死锁，粒度，并发性能。

行锁：innoDB 开销大，加锁慢，会出现死锁，粒度小，锁冲突概率低，并发高。

表锁：myisam 开销小，加锁快，无死锁，粒度大，锁冲突概率高，并发性低。

行锁的三种算法：1. record lock 2.gap lock 3. next-key lock

锁带来的三种问题：1. 脏读  2. 不可重复读 3. 丢失更新

**意向锁**是将锁定的对象分为多个层次，对最细粒度的对象进行上锁，首先需要对粗粒度的对象上锁。

## 触发器

书籍辅助《mysql技术内幕：InnoDB存储引擎》

触发器只能创建在永久表上，不能对临时表创建触发器。触发器是行触发的。

## 视图

视图的主要用途是被用作一个抽象装置，只需要按照视图定义来取数据或更新数据。视图是一种虚拟存在的表。

## 联合索引

联合索引是指对表上的多个列进行索引。

## 主键索引与唯一索引的区别

1.  主键是一种约束，唯一索引是一种索引。两者在本质上是不同的。
2.  主键创建后一定包含一个唯一索引，但是唯一索引不一定是主键。
3.  主键不允许为空，而唯一索引可以为空。
4.  一个表最多只能创建一个主键，但是可以创建多个唯一索引。

## 索引的优缺点

索引是帮助mysql高效获取数据的数据结构。

优点：提高数据查询的效率，降低数据库的IO成本。通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

缺点：实际上索引也是一张表，也需要占用空间。虽然索引大大提高了查询的速度，但是也降低了更新表的速度。索引是不断完善的，需要根据实际需求进行优化调整。

## 什么时候使用索引

1.  主键自动建立唯一索引
2.  频繁作为查询条件的字段应该作为索引
3.  查询中统计或分组字段
4.  排序字段

## 什么时候不能使用索引

1.  频繁更新的字段不适合创建索引
2.  where条件里用不到的字段不适合创建索引
3.  表记录太少
4.  数据重复且分布平均的字段

## 数据库中join的类型与区别

1.  inner join
2.  cross join
3.  left join
4.  right join

## 文件处理三剑客 grep awk sed

1.  grep文件查找
2.  awk按行查找
3.  sed按列查找

## 断点续传

[视频辅助](https://www.bilibili.com/video/BV1RE411A7wd?p=22)

1.  客户端在header中的range字段中指明，请求传输的区间[l, r]
2.  服务器端在header中的content-range返回当前接受的范围和文件总大小。并返回206patial content 状态码。

## TLS协议

[视频](https://www.bilibili.com/video/BV1LK4y1k7N4?p=70)


TLS握手协议：1.交换加解密的安全套件 2.验证通讯双方的身份 3.协商加密的参数。

https是在TCP之上增加了一层TLS层

TLS1.3版本限定了安全套件的数量，防止低版本的安全组件被暴力破解。开始时客户端发送hello并携带一个自己生成的公钥，服务器端选择一个安全套件并将自己生成的公钥发给客户端，客户端收到公钥以后，两段此时都有一个对方发来的公钥和自己的私钥。此时使用ECDH椭圆曲线非对称加密算法，生成一个相同的密钥，这个密钥就用来进行后续的对称加密。

校验过程：判断数字证书中的哈希值和公钥解码的哈希值是否一致。

## TCP两次握手会产生什么问题

[参考链接](https://blog.csdn.net/Runner1st/article/details/88242692)

长期处于半连接状态可能会造成TCP内核中SYN队列的爆满，服务器会在一定时间内终止半连接，并回收资源。如果使用syn洪泛攻击，也可能造成SYN队列爆满，可以使用SYN cookie来解决这个问题。即SYN到达时并不放入SYN队列中，而是将所有的信息写入cookie，当客户端ACK到达时验证cookie中的信息后再分配资源。

TCP两次握手会产生什么问题：已经失效的连接报文段突然又被服务器端收到，造成双方的不一致，进而造成资源浪费。此时如果服务器端发送连接到失效的请求，并返回SYN和ACK后，自认为连接已经建立好了，所以会频繁的发送数据到客户端，而客户端处于closed状态，直接把数据丢弃。同时如果此时客户端想要建立新连接，但是已经又连接占用，也会导致客户端无法建立真正的需求。当客户端老是收到丢弃的数据，客户端就会发一个RST强制服务端关闭连接。

RST和ACK收到时不用再回ACK

## DNS污染

中间人对DNS进行了一些操作导致无法通过域名获得正确的IP。

解决方法:1. 使用第三方DNS解析服务 2.搭建自己的DNS服务器

## http协议

参考书籍《后台开发》

http协议用韵都是客户端发起请求，服务器返回响应，这样就会使得无法实现客户端未发起的请求，而服务器将消息推送给客户端。

请求报文组成部分：1. 请求行 2.请求头 3. 请求空行 4. 请求体

http在1.1版本中，所有的请求头除host外都是可选的。host主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP的URL中提取出来的。不包含host主机头域，服务器会返回400状态码。

1xx: 提示信息，表示请求已接收，继续处理。

2xx: 成功， 表示请求已被成功接收，理解，接受。

3xx: 重定向， 要完成请求必须进行更进一步的操作。

4xx: 客户端错误，请求有语法错误或请求无法实现。

5xx: 服务器错误，服务器未能实现合法的请求。

ssl通信机制：1. 客户端发送client hello报文开始通信。报文中包含SSL指定版本号，加密组件列表，有加密算法和密钥长度。2. 服务器端回应server hello报文作为应答。筛选出SSL版本和加密组件，并发送CA证书，其中包括公钥。3. 第二次交互，客户端生成一个pre-master secret的随机密码串。并使用CA证书中的公钥加密。

## 测试

beta测试是一种验收测试。

## 大数据核心

整理，分析，预测，控制

## string转char*

```c++
char *str = const_cast<char*>(str.c_str());
```

## 深拷贝

浅拷贝就是一个对象拷贝另一个对象的内容以后，其中一个对象的改变还会影响另一个对象的内容。

**编译器默认拷贝构造函数是浅拷贝，如果在类中分配了堆内存，可能导致内存的重复释放。**

**为了解决浅拷贝的问题，通常需要自己实现拷贝构造函数，变为深拷贝。**

```c++
#include <iostream>
using namespace std;
class Person{
public:
	Person(int age, int height){
		this->age = age;
		this->height = new int(height);
	}
	Person(const Person& p){
		this->age = p.age;
		this->height = new int(*p.height); 
	}
	~Person(){
		cout<<"析构"<<endl;
		delete height;
		height = nullptr;
	}
	int age;
	int* height;
};
int main(){
	Person p1(18,190);
	Person p2(p1);
	cout<<p2.age<<" "<<*p2.height<<endl;
	return 0;
}
```

## linux常用命令

-   awk 参数 脚本 文件

    ```shell
     awk '{print  NR NF "\t"  $0, $1 }'
    ```

-   wc -c 字符数 -l 行数 -w 单词数

-   sort

    ```shell
    sort -r coin.txt 逆序
    sort -n coin.txt 数值
    ```


## partition函数

快排中的partition函数在algorithm库中有实现

```c
#include <iostream>
#include <algorithm>
using namespace std;
int main(){
    //按照关键字划分 返回不满足条件的首个位置下标
    vector<int> v{19,8,7,3,5,1,0};
    int key = 6;
    auto t = partition(v.begin(), v.end(), [key](int a){
        return a < key;
    }) - v.begin();
    cout<<t<<endl;
    for(auto x: v) cout<<x<<" ";
    return 0;
}
```

## bind函数

参数绑定。通用的函数适配器。接受一个可调用对象，生成一个新的可调用对象。

```c
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>
using namespace std;
using std::placeholders::_1;
using std::placeholders::_2;
bool cmp( int a,  int b){
    return a > b;
}
int main(){
    //使用bind()将函数转换为仿函数
    //从大到小
    vector<int> v{1,0,99,3,4,12,2};
    sort(v.begin(), v.end(), bind(cmp, _1, _2));
    for(auto x: v) cout<<x<<" ";
    cout<<endl;
    return 0;
}
```

## lambda表达式

未命名的内联函数。一般来说应该减少捕获的数据量，避免捕获指针和引用。捕获列表和函数体是必不可少的。

```c
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>
using namespace std;
int main(){
    //lambda表达式 匿名函数对象
    auto f = [](const int &a){
        return a*a;
    };
    cout<<f(5)<<endl;
    return 0;
}
```

## function函数

函数指针

```c
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>
using namespace std;
int f(int a){
    return a*a;
}
int main(){
    //function是一个模板 相当于函数指针 function<return(args)> ff = func;
    function<int(int)> ff = f;
    cout<<ff(55)<<endl;
    return 0;
}
```

## tuple函数

优势在于传输一次性的一组数据，如果要大量使用，实际上不及结构体清晰明了。

可以将tuple用在map中作为多索引值。可以用来比较两个tuple类型的字典序大小。

**tuple可以存引用**

```c
#include <iostream>
#include <algorithm>
#include <functional>
#include <queue>
#include <tuple>
#include <map>
#include <string>
using namespace std;

int main(){
    //usage
    std::tuple<int, string, char> t(32, "Penny", 'A');
    //output
    cout<<get<0>(t)<<endl; //32
    get<1>(t) = "Alex"; //reference
    //assignment 
    tuple<int, string, char> t2;
    t2 = tuple<int, string, char>(24, "Alex", 'B');
    t2 = make_tuple(17, "Jun", 'C');
    //tuple can store reference 
    string st = "In for a penny";
    tupel<string&> t3(st);
    t3 = make_tuple(ref(st));
    int x;
    string y;
    char z;
    make_tuple(ref(x), ref(y), ref(z)) = t2;
    tie(x, y, z) = t2; // doing the same thing
    tie(x, std::ignore, z) = t2;
    auto t4 = tuple_cat(t2, t3); //concatenate two string
    //tuple traits
    cout<<tuple_size<decltype(t4)>::value<<endl;
    tuple_element<1, decltype(t4)>::type d;
    cout<<d<<endl;
    //Advantage
    //comparison of tuples 
    tuple<int, int , int > time1, time2; //hours mintues seconds
    if(time1 > time2) cout<<"time1 is a later time"<<endl;
    //multi index map
    map<tuple<int, char, float>, string> mp;
    mp[make_tuple(18, 'A', 3.14)] = "Curiosity kills the cat";
    //fast change value
    int a, b, c;
    tie(c, b, a) = make_tuple(a, b, c);
    return 0;
}
```



## 一致性哈希

通过是为了解决传统哈希算法上的不足而提出来的。主要是增减机器是，传统哈希算法对于数据迁移的成本很高。一致性哈希也是使用取模的思想，只不过将哈希值空间组织成一个圆环，然后每个机器顺时针负责一段数据的存储，当增加机器或者减少机器时，把对应的数据迁移到附近的机器上就行，其他机器不用发生改动。但是存在一个不足，当机器数量比较少时，无法做到在环上均匀分布。于是引入虚拟节点，每个物理机器有相同数量的虚拟节点，通过虚拟节点去寻找位置，然后映射到物理机上。

## 海量数据问题

小根堆+归并

## 生成随机数

线性同余算法

```c++
#include<iostream>
using namespace std;
//x_{n+1} = a*x_n + c mod m
//a = 48271 
int main(){
	long long a = 48271, c = 0, x = 1;
	long long m = INT_MAX;
	for(long long i = 0; i < 10; i++){
		x = (a*x+c) % m;
		cout<<x<<endl;
	}
	return 0;
} 
```

## 什么是socket

socket是linux文件的一种类型。socket通过绑定IP和端口可以实现再进程间通信。创建一个socket文件描述符指向两个缓冲区，所以可以实现全双工通信。

## epoll的优势

连接的文件描述符比较多，但是活跃的文件描述符比较少时，比select和poll效率更高。

epoll三个主要的函数：

1.  epoll_create()
2.  epoll_ctl()
3.  epoll_wait()

## ET和LT的区别

1.  ET称为边沿触发，在调用epoll_wait函数监听的时候，如果有满足的事件，则该函数进行返回，返回值是满足监听事件的文件描述符数量。ET模式下，只会响应一次，即使部分文件描述符的事件没有进行处理。**当发送接收缓冲区状态发生改变时，触发读写事件。边沿触发模式要求一直读写，直到读写完或者返回EAGAIN**
2.  LT称为水平触发，如果epoll_wait有满足条件的事件，会一直返回。增加了epoll_wait函数的调用次数。所以通常在并发服务器上，多使用ET模式。如果系统中有大量不需要读写的就绪文件描述符，而它每次都会返回，这样会大大降低检索自己关心的就绪文件描述符的效率。**接收缓冲区不为空，有数据可读，读事件一直触发。发送缓冲区不为满，有数据可写，则写事件一直触发。**



## ET为什么要用非阻塞而不是阻塞

1.  阻塞模式，程序在读取数据时无法知道什么时候读完，会一直阻塞在read函数上，即使已经读完了数据。
2.  非阻塞模式，**程序使用while循环读取数据，读完以后read会返回，errno被设置为EAGAIN。**



## 五种网络IO模型

1.  阻塞IO
2.  非阻塞IO
3.  IO多路复用
4.  信号驱动IO
5.  异步IO

>   前4个都是同步IO。IO多路复用也是阻塞的，但是没有阻塞在send和recv上，而是阻塞在select，poll和epoll上。

1.  同步：进程在数据由内核空间复制回进程缓冲区时不能干别的事。
2.  异步：在数据准备完成，由内核缓冲区拷贝到进程缓冲区后通知进程，在等待通知的这段事件里，进程可以干别的事情。
