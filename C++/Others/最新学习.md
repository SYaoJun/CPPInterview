## 最左前缀法则（理解成爬楼梯）

[视频辅助](https://www.bilibili.com/video/BV1zJ411M7TB?p=55)

sql查询条件中需要包含复合索引中的最左列，不能跳跃索引，否则索引失效。查询条件在where中出现的顺序没关系，只要按照最左前缀原则出现了，就会走索引。如果跳跃了索引，查询条件中满足最左前缀的部分走索引，到跳跃的部分时索引失效。

## 索引失效

1.  范围查询后其右边的列，索引失效。即索引某个字段使用了范围查询，他右边的索引将不再走索引。
2.  在索引列上进行运算操作，索引失效。（子串匹配查询）
3.  字符串不加单引号，索引失效。
4.  用or分割的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。
5.  以%开头的like模糊查询，索引失效。
6.  如果mysql评估全表扫描更快，索引失效。
7.  is NULL, is NOT NULL, 有时索引失效。
8.  in走索引，而not in索引失效。

## 优化

1.  使用索引。
2.  根据sql实际解析的顺序，调整索引的顺序。
3.  **尽量使用覆盖索引，避免select *。**覆盖索引是指只出现在索引中的字段。
4.  尽量使用复合索引，而少使用单列索引。
5.  优化insert。一次插入多条数据。事务改为手动提交，分段提交。按主键顺序插入。
6.  优化order by尽量使用using index 而避免使用filesort

## 定位低效sql语句

1.  explain分析执行计划（索引失效或者关联查询太多join）
2.  慢查询日志
3.  show profiles

## mysql分库分表

[视频辅助](https://www.bilibili.com/video/BV1bE411d7FF?p=14)

主从集群也就是读写分离，读写分离只是分担了访问的压力，存储的压力并没有解决。数据库集群环境后都是多台slave，基本满足了读取操作，但是频繁写入堆master性能影响比较大，这个时候，单库并不能解决大规模并发写入的问题。

分库分表带来的问题：**1. 联合查询问题，join不再适用。2.事务问题，变成了分布式事务。好处：减少大量数据写入时锁对查询的影响。**按照存储类别分：用户库，业务库，内存库，图片库，日志库，统计库。

分表：垂直分表和水平分表。解决单张表记录太多的问题。切分策略和导航路由。单表的容量超过500W时建议水平拆分。不到最后一步，不要轻易进行水平分表。

开源方案：1. msyql fabric 2.atlas 3.TDDL 4.mysql proxy 小巧精干，能力有限。+ master/slave 构成一个简单版的读写分离和负载均衡。

主从复制，读写分离---> 垂直分库(每个库可以带slave)--->分区---->水平分表。中间各种通信，调度，维护和编码要求更高。

## 主从复制

一主多从。mysql复制是异步并串行化的。原理：slave从master读取binlog进行数据同步。主要分为3步：

1.  master将改变记录到二进制日志(binary log)。这些记录过程叫做二进制日志事件binary log events。
2.  slave从master的binary log events拷贝到它的中继日志relay log
3.  重做中继日志中的事件，将改变应用到自己的数据库中。

## 锁机制

锁可以对有限的资源进行保护，解决隔离和并发的矛盾。通过锁机制可以实现事务的隔离性要求，使得事务可以并发地工作。

按操作分：读锁（共享锁） 写锁（排他锁）

按粒度分：行锁（偏写）表锁（偏读）

锁使用的考虑点：开销，加锁速度，死锁，粒度，并发性能。

行锁：innoDB 开销大，加锁慢，会出现死锁，粒度小，锁冲突概率低，并发高。

表锁：myisam 开销小，加锁快，无死锁，粒度大，锁冲突概率高，并发性低。

行锁的三种算法：1. record lock 2.gap lock 3. next-key lock

锁带来的三种问题：1. 脏读  2. 不可重复读 3. 丢失更新 

**意向锁**是将锁定的对象分为多个层次，对最细粒度的对象进行上锁，首先需要对粗粒度的对象上锁。

## 触发器

书籍辅助《mysql技术内幕：InnoDB存储引擎》

触发器只能创建在永久表上，不能对临时表创建触发器。触发器是行触发的。

## 视图

视图的主要用途是被用作一个抽象装置，只需要按照视图定义来取数据或更新数据。视图是一种虚拟存在的表。

## 联合索引

联合索引是指对表上的多个列进行索引。

## 主键索引与唯一索引的区别

1.  主键是一种约束，唯一索引是一种索引。两者在本质上是不同的。
2.  主键创建后一定包含一个唯一索引，但是唯一索引不一定是主键。
3.  主键不允许为空，而唯一索引可以为空。
4.  一个表最多只能创建一个主键，但是可以创建多个唯一索引。

## 索引的优缺点

索引是帮助mysql高效获取数据的数据结构。

优点：提高数据查询的效率，降低数据库的IO成本。通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

缺点：实际上索引也是一张表，也需要占用空间。虽然索引大大提高了查询的速度，但是也降低了更新表的速度。索引是不断完善的，需要根据实际需求进行优化调整。

## 什么时候使用索引

1.  主键自动建立唯一索引
2.  频繁作为查询条件的字段应该作为索引
3.  查询中统计或分组字段
4.  排序字段

## 什么时候不能使用索引

1.  频繁更新的字段不适合创建索引
2.  where条件里用不到的字段不适合创建索引
3.  表记录太少
4.  数据重复且分布平均的字段

## 数据库中join的类型与区别

1.  inner join
2.  cross join
3.  left join
4.  right join

## 文件处理三剑客 grep awk sed

1.  grep文件查找
2.  awk按行查找
3.  sed按列查找

## 断点续传

[视频辅助](https://www.bilibili.com/video/BV1RE411A7wd?p=22)

1.  客户端在header中的range字段中指明，请求传输的区间[l, r]
2.  服务器端在header中的content-range返回当前接受的范围和文件总大小。并返回206patial content 状态码。

## TLS协议

[视频](https://www.bilibili.com/video/BV1LK4y1k7N4?p=70)

![TLS1.2密码套件](E:\work\pics\tls.png)

TLS握手协议：1.交换加解密的安全套件 2.验证通讯双方的身份 3.协商加密的参数。

https是在TCP之上增加了一层TLS层

TLS1.3版本限定了安全套件的数量，防止低版本的安全组件被暴力破解。开始时客户端发送hello并携带一个自己生成的公钥，服务器端选择一个安全套件并将自己生成的公钥发给客户端，客户端收到公钥以后，两段此时都有一个对方发来的公钥和自己的私钥。此时使用ECDH椭圆曲线非对称加密算法，生成一个相同的密钥，这个密钥就用来进行后续的对称加密。

校验过程：判断数字证书中的哈希值和公钥解码的哈希值是否一致。

## TCP两次握手会产生什么问题

[参考链接](https://blog.csdn.net/Runner1st/article/details/88242692)

长期处于半连接状态可能会造成TCP内核中SYN队列的爆满，服务器会在一定时间内终止半连接，并回收资源。如果使用syn洪泛攻击，也可能造成SYN队列爆满，可以使用SYN cookie来解决这个问题。即SYN到达时并不放入SYN队列中，而是将所有的信息写入cookie，当客户端ACK到达时验证cookie中的信息后再分配资源。

TCP两次握手会产生什么问题：已经失效的连接报文段突然又被服务器端收到，造成双方的不一致，进而造成资源浪费。此时如果服务器端发送连接到失效的请求，并返回SYN和ACK后，自认为连接已经建立好了，所以会频繁的发送数据到客户端，而客户端处于closed状态，直接把数据丢弃。同时如果此时客户端想要建立新连接，但是已经又连接占用，也会导致客户端无法建立真正的需求。当客户端老是收到丢弃的数据，客户端就会发一个RST强制服务端关闭连接。

RST和ACK收到时不用再回ACK

## DNS污染

中间人对DNS进行了一些操作导致无法通过域名获得正确的IP。

解决方法:1. 使用第三方DNS解析服务 2.搭建自己的DNS服务器  

## http协议

参考书籍《后台开发》

http协议用韵都是客户端发起请求，服务器返回响应，这样就会使得无法实现客户端未发起的请求，而服务器将消息推送给客户端。

请求报文组成部分：1. 请求行 2.请求头 3. 请求空行 4. 请求体

http在1.1版本中，所有的请求头除host外都是可选的。host主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP的URL中提取出来的。不包含host主机头域，服务器会返回400状态码。

1xx: 提示信息，表示请求已接收，继续处理。

2xx: 成功， 表示请求已被成功接收，理解，接受。

3xx: 重定向， 要完成请求必须进行更进一步的操作。

4xx: 客户端错误，请求有语法错误或请求无法实现。

5xx: 服务器错误，服务器未能实现合法的请求。

ssl通信机制：1. 客户端发送client hello报文开始通信。报文中包含SSL指定版本号，加密组件列表，有加密算法和密钥长度。2. 服务器端回应server hello报文作为应答。筛选出SSL版本和加密组件，并发送CA证书，其中包括公钥。3. 第二次交互，客户端生成一个pre-master secret的随机密码串。并使用CA证书中的公钥加密。

## 测试

beta测试是一种验收测试。

## 大数据核心

整理，分析，预测，控制

