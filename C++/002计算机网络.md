## TCP头部

1.  16位源端口
2.  16位目的端口
3.  32位序号
4.  32位确认序号
5.  4位TCP头部长度  单位为4字节
6.  6位标志位
7.  16位滑动窗口
8.  16位校验和
9.  16位紧急指针

注意：**TCP的包没有IP地址**，只有源端口和目的端口。一个TCP连接需要4个元组来表示一个连接。（源端口，目的端口，源IP，目的IP）

## 为什么建立连接需要3次握手

主要是初始化序列号和协商最大报文段长度。

## 粘包问题

udp不存在粘包的问题，因为udp是个数据包协议，也就是两段数据间有界限的。要么收不到，要么全收。

产生粘包的原因：nagle算法为了改善网络传输效率，延迟发送数据。应用层由于某些原因不能及时取出TCP的数据，导致TCP缓冲区存放了多段数据。

解决方式：封包和拆包。包头存放一个变量记录包体的长度。在所发送的内容前，加上发送内容的长度。

## HTTP原理

http协议是**应用层**协议，通过**请求响应**的方式在客户端和服务器端进行通信。

http协议是以明文的方式进行传输，并且是**无状态**的通信协议。

## http与https的区别

1.  传输方式：http是**明文传输，极易被监听和篡改。**而https加入了ssl层，数据经过了加密，从而保护了传输数据的隐私和完整性。
2.  身份认证： http没有身份认证，而https经过证书颁发机构的多重认证。
3.  连接端口：**http为80  https为443**
4.  实现成本：**http基本没有成本，https需要申请证书，同时在加密解密上需要消耗更多的CPU资源，访问速度有可能降低。**
5.  加锁的图标显示 谷歌和百度搜索的排名会对非https的排名有影响

私钥能解密，但是不能确认是哪个客户端发送的消息，任何人都可以抵赖。为了防止抵赖，可以使用数字签名。

**https是http的安全版，在http的基础上增加了SSL安全层。**

基于性能的考虑，https一般使用非对称加密算法获得密钥，再用对称加密算法对消息内容进行加密。

https发送请求的过程：

1.  第一步，客户端和服务器端交换SSL版本和**加密组件列表**，同时服务器端将密钥和签名证书发给客户端。
2.  第二步：客户端根据证书和密钥进行验证，通过以后协商传输的密钥。这一步使用非对称加密算法。
3.  第三步：当双方都获得密钥，且校验码没有问题。则进行TCP三次握手，此时采用对称加密算法，提高效率。



## http1.0 与 http1.1的区别

1.  **长连接：**HTTP 1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。
2.  **带宽优化：** **HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。**
3.  **新增响应状态码：**100 continue 已经收到第一部分，正等待剩余部分。 101 switch protocols 服务器已确认切换协议。
4.  **host头域：**允许物理主机上多个虚拟主机共享一个IP
5.  缓存机制更灵活，新增control-cache头域
6.  增加了5个请求方法：put delete connect options trace



## get和post的区别

都是http的请求方式。

区别在于：

1.  **用途上：**get一般用于获取资源，post一般用于创建资源。
2.  位置上：get请求的的数据会在**地址栏上显示出来**，以**问号**分割url与传输数据，多个参数用**取地址符**连接。而post的数据放在请求体中。
3.  **安全性上：**优于get将信息显示在地址栏，所以对于用户密码等个人隐私信息很不安全，而post放在请求体中，在安全性上要稍微好点。
4.  **长度限制：**get使用地址栏发送数据，而地址栏的长度是有限的。
5.  **幂等性上：**get操作没有副作用，多次操作产生的副作用相同，所以get是幂等的，而post用于创建资源是会又副作用的，所以post不是幂等的。



## cookie和session

**cookie和session都是跟踪会话的机制。**

1.  **存储位置：**cookie保存在客户端用来记录信息和确定用户身份，session保存在服务端同样用来记录和确定身份。
2.  **安全性：**cookie放在客户端很容易被查看或者破解，没有session安全。
3.  **关联性：**session的运行依赖于session id 而session id 存在cookie中。如果浏览器禁止了cookie，可以使用**url地址重写来传递session id**
4.  **性能上：**session会在有效期内存在于服务器的数据库或者文件，当请求过多时，服务器性能会下降。
5.  **大小上：**单个cookie保存的大小不能超过4k

使用cookie来管理session以弥补http中无状态特性。通过对set-cookie头域写入session ID可以免登录，提高访问的效率。

握手优化：**session缓存， session key 放在内存，有内存消耗， 负载均衡后找不session key。session ticket 集群可以共享。**



## TCP和UDP的区别

1.  TCP: **面向连接的安全的流式协议**，连接的时候进行三次握手，数据发送的时候会进行数据确认，数据丢失之后，会进行数据重传。 确认和重传机制。
2.  UDP: **面向无连接的不安全的报文传输**，发出去就不管了，收则全收，丢则全丢。



## 3次握手和4次挥手

TCP三次握手：客户端向服务器端：发送SYN=1和序号seq 服务器端向客户端：回应确定信号同意连接ACK=1以及自己的连接请求SYN=1还有序号seq 客户端回应服务器端：ACK=1告诉对方它已经知道了服务器端同意，连接成功。

 TCP四次挥手：主动关闭方发送关闭信号，被动关闭方收到信号。然后进入半关闭状态，关闭的一方能接收数据但是不能发送数据。 等到另一个未关闭的一方，发起关闭信号以后，进入TIME_WAIT状态，等待对方2MSL之后，彻底关闭。



## 3次握手55555555

客户端发起连接，也就是C语言中的connect函数，发送一个SYN=1的标志位，同时携带一个序号。

服务器端有一个accept函数，用于响应连接。服务器端响应连接后回复一个ACK=1的标志位，并且也发送一个SYN=1的标志位建立连接。

客户端收到服务器端的ACK应答以后，说明建立成功。两者都同时进入established状态。同时accept和connect函数调用成功，并返回1。

## 4次挥手55555555

主动关闭方向被动关闭放发送FIN标志位，表示要断开连接。被动关闭方同意关闭，并回发ACK标志位。此时主动关闭放进入FIN_WAIT_2状态。以后主动关闭方仍然可以接收数据，但是不可以再发送数据。

当另一方也决定关闭时，会发送FIN标志位，接收方回复ACK同意关闭，并且自身进入Time_wait状态，等待2MSL时长后关闭。发送方如果收到ACK应答后，就直接关闭，如果没有收到会一直发FIN标志位。

## 滑动窗口

流量控制：防止发送方发的太快，耗尽接收方的资源。

控制机制：滑动窗口

在TCP报文的头部有一个**16位的窗口大小**，用于告诉发送方接收方**可用的缓冲区大小**。

## 拥塞窗口

拥塞控制：防止发送方发的太快，使网络来不及处理，从而导致**网络拥塞**。

控制机制：拥塞窗口

## 慢启动 拥塞避免 快重传 快恢复

1.  **慢启动：**为了防止大量数据瞬间注入网络，引起网络阻塞。慢启动算法设定，最开始窗口为1个最大报文长度。一个传输轮次增加一倍的窗口大小。当达到慢开始门限后，执行拥塞避免算法。
2.  **拥塞避免：** 每个传输轮次将窗口增加一个单位，即加法增长。
3.  **快重传：** 当收到3个重复确认以后，执行快恢复算法。慢开始门限和发送窗口减半，然后发缺失的数据，进行加法增长，重新进入拥塞避免阶段。
4.  **快恢复：**慢开始门限减半，发送拥塞窗口设定为门限加3。如果后面依旧收到重复的ACK则进行加法增长窗口，如果收到新的ACK，则拥塞窗口设定为慢开始门限的值，并重新进入拥塞避免阶段。

**超时进入的是慢启动，重复确认才进入快恢复。**

选择性重传在options中left edge和right edge告诉发送方已经收到的报文序号

## TCP粘包问题

**udp不会出现粘包。**发送方发送的若干包数据到接收方接收时，包粘在了一起。

造成粘包的原因时因为发送端延迟发送或者接收方没有及时接收缓冲区中的数据。

通常可以使用以下三种方式来解决

1.  编程时设定立即发送的操作指令
2.  把数据长度与消息一起发送。
3.  使用特殊标记来区分消息的间隔



## HTTP和HTTPS有什么不同

HTTP协议是一种使用明文数据传输的网络协议。HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了**数据加密。**在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息让然是安全的。这就是HTTP和HTTPS的最大区别。

## 在浏览器地址栏键入URL，按下回车之后会经历以下流程

1.  浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;（递归式和迭代式）
2.  解析出 IP 地址后，**根据该 IP 地址和默认端口 80**，和服务器建立TCP连接;
3.  浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
4.  服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5.  释放 TCP连接;
6.  浏览器将该 html 文本并显示内容; 　



## UDP如何做到可靠

想要做到可靠，必须要做到**无重复，无丢失，无错误，无失序。**借鉴TCP的可靠机制

1.  发送时进行**编号**
2.  接收方收到数据发出**应答信号**（超时重传，3次确认重传）
3.  增加**校验位**

## NAT DNS ARP

1.  NAT用于实现从**内部IP地址到外部IP地址的映射** 
2.  DNS提供域名到IP地址的映射或者反过来 
3.  ARP提供**IP到MAC地址的映射**

## DNS

基于UDP的协议

1.  递归查询：父域名**代替当前服务器递归查询**，最后依次返回 
2.  迭代查询：父域名服务器告诉当前服务器**下一次查询的位置**

## http状态码

1.  100 continue 等待继续发送
2.  200 ok 请求成功
3.  **206 patial content 部分资源**
4.  301 永久重定向
5.  302 临时重定向 307
6.  400 客户端请求报文语法错误
7.  403 禁止访问
8.  404 资源不存在
9.  408 请求超时
10.  500 服务器内部错误
11.  503 服务器不可用

## http 2.0  SPDY

1.  二进制分帧
2.  多路复用
3.  首部压缩
4.  服务器推送

## http 3.0 QUIC+UDP

1.   0 RTT
2.  **没有队头阻塞的多路复用**
3.  前向纠错

## 网络安全

1.  **sql注入：**用户提交一段数据库查询代码，根据程序返回的结果获得它想得知的数据。
2.  **dos攻击：** 让运行的服务器呈停止状态。集中请求造成资源过载，攻击安全漏洞使服务停止。

## TCP原理

面向连接，可靠的，基于字节流的传输层协议

## 七层模型

物数网传会表应

ping是从应用层直接使用网络层的ICMP协议的，不经过传输层。原始套接字直接使用网络层的IP。

两台电脑通信：网线+不同的IP地址和子网掩码，即处于同一网段。

TCP和UDP可以同时使用相同的端口。

应用程序可以同时使用TCP和UDP两个协议。

## hub集线器

可以实现多个IP主机通信，但是hub的实现方式是广播，容易产生拥堵。

## switch交换机

是集线器的升级版，可以广播可单播。ARP不知道对方MAC地址时，先广播6个ff的MAC地址，所有网卡都会接收，但是只有目的IP会单播回应，其他的都会丢弃。然后发送方收到正确的MAC后再单播传输数据。

## ARP攻击

给两个MAC地址响应ARP广播的目的IP，经由中间人，窃取信息后再转发到正确的地址。

## 默认网关

在同一个交换机连接的网络中，属于同一网段，用不到默认网关。网关用来传递两个不同网段的通信，默认网关通常是路由器。当通信的数据不在当前网段时，即发给默认网关。路由器就是用来连接不同网段的，用来构建一个更大的网络。在传输不同的网段信息时，源IP和目的IP是不变的，源MAC和目的MAC是改变的，每经过一个路由器修改一次，记录的是下一次的目的，和这一次的发送MAC。

## 延迟确认

ack会随着响应数据发送给对方，如果没有响应的数据就会等待200ms左右，在这期间如果有对方确认到达则立即发送。如果200ms后仍然没有数据需要发送则单独发送ACK。目的是节省带宽。

## Nagle算法

1.  没有已发送未确认报文段时，立即发送数据。
2.  存在未确认报文段时，达到mss时再发。

同时有nagle算法和延迟确认存在时会导致网络效率下降，通常会关闭延迟确认和nagle算法。

```c
setsockopt(s,IPPROTO_TCP,TCP_QUICKACK,(int*){1}, sizeof(int)); //关闭延迟确认
setsockopt(client_fd, SOL_TCP, TCP_NODELAY,(int[]){1}, sizeof(int)); //关闭nagle算法
```

## 忽略SIGPIPE信号

客户端和服务器端连接建立后，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST响应，第二次写数据时，内核会向进程发送一个SIGPIPE信号，通知进程此连接已断开，而这个信号的默认处理方式是终止进程，服务器直接关闭。

```c
signal(SIGPIPE, SIG_IGN)
```

SIGSEGV 11 访问地址无效 SIGIO 29异步通知信号  SIGKILL 9 无条件终止 

## 传输层与网络层的区别

1.  传输层位于网络层之上，为不同主机上的应用进程提供逻辑通信。**端到端传输**。
2.  网络层负责**ip数据报的产生**以及ip数据包在网络中的**路由转发**。

## 状态码499

服务器端处理的时间过长，客户端主动关闭了连接。

## 分块编码

transfer-encoding:chunked **响应头域** 它允许服务器发送给客户端的数据分成多个部分，并且不需要预先直到发送数据的总大小。

## close_wait

基本的思想就是要检测出对方已经关闭的socket，然后关闭它。维持一个心跳包或者设置一个超时时间。