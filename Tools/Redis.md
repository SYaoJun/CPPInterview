## 1、缓存雪崩★★★

缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法：

- 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
- 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

## 2、缓存穿透★★★

一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

## 3、redis持久化机制★★★

Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）

RDB：从内存写入磁盘

AOF：记录操作的步骤

1. Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。快照持久化是Redis默认采用的持久化方式。

2. 与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

## 4、redis的功能

redis缓存，可用来做分布式锁，支持事务，持久化，lua脚本，lru事件驱动，多集群方案。

## 5、数据类型

- string
- list
- set
- hash
- zset

## 6、redis过期时间

1. 定期删除：redis默认是每隔 100ms 就**随机抽取**一些设置了过期时间的key，检查其是否过期，如果过期就删除。
2. 惰性删除：查询的时候再删。

## 7、redis内存淘汰机制

1. Volatile-lru
2. volatile-ttl
3. volatile-random
4. allkeys-lru
5. allkeys-random
6. no-eviction

## 8、redis事务

Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。


## 9、Redis和DB之间的数据一致性怎么保证

要保证一致性要强调两点前提：
- 缓存必须要有过期时间
- 保证缓存和数据的最终一致性，强一致性不容易做到

为什么需要有过期时间？

首先对于缓存来说，当它的命中率越高的时候，我们的系统性能也就越好。如果某个缓存项没有过期时间，而它命中的概率又很低，这就是在浪费缓存的空间。而如果有了过期时间，且在某个缓存项经常被命中的情况下，我们可以在每次命中的时候都刷新一下它的过期时间，这样也就保证了热点数据会一直在缓存中存在，从而保证了缓存的命中率，提高了系统的性能。

设置过期时间还有一个好处，就是当数据库跟缓存出现数据不一致的情况时，这个可以作为一个最后的兜底手段。也就是说，当数据确实出现不一致的情况时，过期时间可以保证只有在出现不一致的时间点到缓存过期这段时间之内，数据库跟缓存的数据是不一致的，因此也保证了数据的最终一致性

为什么不追求强一致性？

这个主要是个权衡的问题。数据库跟缓存，以Mysql跟Redis举例，毕竟是两套系统，如果要保证强一致性，一般都要引入分布式一致性协议或者分布式锁等等，一是实现上有一定的难度，增加系统的复杂性，对性能会有一定的影响，如果真的需要强一致性，缓存这一层的必要性有待具体分析

**DB和缓存的读写顺序**

经典的[Cache-Aside pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)，这个方案的思路是：

1. 失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中
2. 命中：程序先从缓存中读取数据，如果命中，则直接返回
3. 更新：程序先更新数据库，在删除缓存

一般对于1和2两步中需要考虑的细节较少，主要是第三步的更新，如何确保更新的时候仍然可以确保缓存数据的一致性

一共有四种可能

1. 先更新缓存，再更新数据库
2. 先更新数据库，再更新缓存
3. 先删除缓存，再更新数据库
4. 先更新数据库，再删除缓存

**1、先更新缓存，再更新数据库**

不管是操作数据库还是操作缓存，都有失败的可能。如果我们先更新缓存，再更新数据库，假设更新数据库失败了，那数据库中就存的是老数据。当然你可以选择重试更新数据库，那么再极端点，负责更新数据库的机器也宕机了，那么数据库中的数据将一直得不到更新，并且当缓存失效之后，其他机器再从数据库中读到的数据是老数据，然后再放到缓存中，这就导致先前的更新操作被丢失了，因此这么做的隐患是很大的

从数据持久化的角度来说，数据库当然要比缓存做的好，我们也应当以数据库中的数据为主，所以需要更新数据的时候我们应当首先更新数据库，而不是缓存

**2. 先更新数据库，再更新缓存**

主要有两个问题，首先是并发的问题：假设线程A（或者机器A，道理是一样的）和线程B需要更新同一个数据，A先于B但时间间隔很短，那么就有可能会出现：

1. 线程A更新了数据库
2. 线程B更新了数据库
3. 线程B更新了缓存
4. 线程A更新了缓存

按理说线程B应该最后更新缓存，但是可能因为网络等原因，导致线程B先于线程A对缓存进行了更新，这就导致缓存中的数据不是最新的。

第二个问题是，我们不确定要更新的这个缓存项是否会被经常读取，假设每次更新数据库都会导致缓存的更新，有可能数据还没有被读取过就已经再次更新了，这就造成了缓存空间的浪费。另外，缓存中的值可能是经过一系列计算的，而并不是直接跟数据库中的数据对应的，频繁更新缓存会导致大量无效的计算，造成机器性能的浪费

这种方案不可取，应当考虑删除缓存

**3. 先删除缓存，再更新数据库**
这个方案的问题也是很明显的，假设现在有两个请求，一个是写请求A，一个是读请求B，那么可能出现如下的执行序列：

1. 请求A删除缓存
2. 请求B读取缓存，发现不存在，从数据库中读取到旧值
3. 请求A将新值写入数据库
4. 请求B将旧值写入缓存

这样就会导致缓存中存的还是旧值，在缓存过期之前都无法读到新值。这个问题在数据库读写分离的情况下会更明显，因为主从同步需要时间，请求B获取到的数据很可能还是旧值，那么写入缓存中的也会是旧值

**4. 先更新数据库，再删除缓存**

这种方式是最常用的，但并不代表没有任何问题。
依然假设有两个请求，请求A是查询请求，请求B是更新请求，那么可能会出现下述情形

1. 先前缓存刚好失效
2. 请求A查数据库，得到旧值
3. 请求B更新数据库
4. 请求B删除缓存
5. 请求A将旧值写入缓存

上述情况确实有可能出现，但是出现的概率可能不高，因为上述情形成立的条件是在读取数据时，缓存刚好失效，并且此时正好又有一个并发的写请求。考虑到数据库上的写操作一般都会比读操作要慢，（这里指的是在写数据库时，数据库一般都会上锁，而普通的查询语句是不会上锁的。当然，复杂的查询语句除外，但是这种语句的占比不会太高）并且联系常见的数据库读写分离的架构，可以合理认为在现实生活中，读请求的比例要远高于写请求，因此我们可以得出结论。这种情况下缓存中存在脏数据的可能性是不高的

那如果是读写分离的场景下，按照如下所述的执行序列，一样会出问题：

1. 请求A更新主库
2. 请求A删除缓存
3. 请求B查询缓存，没有命中，查询从库得到旧值
4. 从库同步完毕
5. 请求B将旧值写入缓存

如果数据库主从同步比较慢的话，同样会出现数据不一致的问题。事实上就是如此，毕竟我们操作的是两个系统，在高并发的场景下，我们很难去保证多个请求之间的执行顺序，或者就算做到了，也可能会在性能上付出极大的代价

那为什么我们应当先更新数据库呢？因为缓存在数据持久化这方面往往没有数据库做得好，而且数据库中的数据是不存在过期这个概念的，我们应当以数据库中的数据为主，缓存因为有着过期时间这一概念，最终一定会跟数据库保持一致。

**还有没其他办法**

1. 引入消息队列，将删除缓存的操作作为一条消息，放入消息队列
2. 订阅Binlog，比如DataBus来监控Binlog，一旦数据发生变更，Binlog消息通知回来去删除缓存

**删缓存有可能出现缓存击穿问题怎么解决**

采用删除缓存的方案，在高并发场景下可能会导致缓存击穿（这个跟缓存穿透还有点区别），也就是大量的请求同时去查询同一个缓存，但是这个缓存又刚好过期或者被删除了，那么所有的请求全部都会打到数据库上，导致严重的性能问题。

当一个线程需要去访问这个缓存的时候，如果发现缓存为空，则需要先去竞争一个锁，如果成功则进行正常的数据库读取和写入缓存这一操作，然后再释放锁，否则就等待一段时间之后，重新尝试读取缓存，如果还没有数据就继续去竞争锁。这个是单机场景

如果有多台机器同时去访问同一个缓存项该怎么办呢？如果机器数不是很多的话，这种情况一般来说也不会成为一个问题，不过这里有个优化点，就是从数据库读取到数据之后，再对缓存做一次判断，如果缓存中已经存在数据，就不需要再写一遍缓存了。但是如果机器数也很多的话，那么就得考虑上分布式锁了

但是需要强调锁的代价，分布式锁对性能有影响，不能盲目上分布式锁，系统越简单越好

**需要强一致性怎么做**

对缓存增加分布式读写锁，读写锁的特性可以多读，但是只能单写，利用读写锁，可以保证读请求不会读取到旧数据，但是写的过程所有读请求都会被阻塞，这个问题再高并发的情况下有可能把会服务器的请求线程池打满

这里用到的分布式读写锁并没有解决缓存击穿的问题，因为从读请求的视角来看，如果发生了更新数据库的情况，读请求要么被阻塞，要么就是缓存为空，需要从数据库读取数据再写入缓存。为了防止因缓存失效或被删除导致大量请求直接打到数据库上导致数据库崩溃