# 数据库概论
- 索引
- 事务
- 锁
- 并发控制
- 存储
- 副本
- 恢复
- 调优
## 索引
### 什么是索引
- 索引是数据表中对字段进行排序的一种数据结构。常用的索引有
1. B+
2. AVL 
3. Hash
4. RBtree
- 哈希表不利于范围查找。
- 红黑树在数据量大的时候性能会下降。

### 联合索引
- 对多个字段同时建立的索引。Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，**跳跃索引查询**就会导致索引失效。
### 唯一索引
### 覆盖索引
### 最左匹配原则
## B+树

1.  具有n个关键字的节点含有n个分支。而在B树中，具有n个关键字的节点含有n+1个节点。
2.  B+树的叶子节点包含了所有关键字，并且包含信息。
3.  B+树非叶子节点只起索引作用，不存数据。
4.  B+数在叶子节点使用指针将前后磁盘块中的索引连接起来，形成一个线性链表，方便范围查询。


## B树和B+树的区别

1.  B树：叶节点具有相同的深度，**所有索引元素不重复**，节点中的数据索引从左到右递增排列。
2.  B+树：**非叶子节点不存储数据，只存储索引**，叶子节点包含了全部的关键字且存储数据。叶子节点用指针连接从左往右递增排序，提高区间访问的性能。


## 数据库三大范式

1.  数据库中的**所有字段**都是**不可分割的原子值**
2.  满足第一范式的前提下，除主键外的**每一列**都必须**完全依赖于主键**。如果不完全依赖，只能发生在联合主键下。
3.  满足第二范式的前提下，除开主键列的其他**列之间**不能有**传递依赖**关系。
## 事务
### 事务的特性
1. 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
4. 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
### 隔离级别
1. READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
2. READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
3. REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
4. SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读

### 不同隔离级别存在的问题
1. 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
2. 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失
3. 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读
4. 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
 
### 左右联接

- inner join： 只保留两表完全匹配的结果集
- left join: 返回左表所有的行，右表中没有返回为null
- full join: 全外联接 ，返回左表和右表中所有没有匹配的行。mysql不支持 full join，使用left join union right join来实现。

### 主键

主键：**唯一且非空。**一个表有且只能由一个主键约束。创建主键会自动创建对应的索引，同样删除主键，对应的索引也会被删除。
### 外键
外键约束：如果定义了外键约束，主表中没有的数据在子表中是**不可以被使用的**。主表中的记录被子表引用，是不可以被删除的。


### 查询

分组查询：count() sum() max() min() avg()

聚合查询：7种 A B A∪B A∩B   A - A∩B  B - A∩B  A∪B - A∩B

左连接： A - A∩B   右连接：B - A∩B  内连接：A∩B

## 悲观锁和乐观锁

1.  悲观锁： **每次去拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁。悲观锁由数据库自己实现，共享锁和排他锁是悲观锁的不同实现。悲观锁的缺点：效率低，并行差，增加死锁的概率。**
2.  乐观锁：**每次去拿数据都认为别人不会修改，所以不会上锁。乐观锁适用于读多，写少的场景。乐观锁常见的实现方式：版本号机制和CAS自旋算法。乐观锁的缺点：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。**

## 调优
### 什么时候应该创建索引

1.  频繁查询字段

### 什么时候不应该创建索引

1.  where条件里用不到的字段
2.  频繁更新的字段
3.  表记录太少<300W
4.  重复且平均的表字段

### explain 查看执行计划

使用explain关键字可以**模拟优化器执行sql查询语句**，从而知道mysql是如何处理sql语句的。分析查询语句或表结构的性能瓶颈。


### show profile

用来分析当前会话中**语句执行的资源消耗情况。**

### 分库分表
[MySQL大表优化方案](https://segmentfault.com/a/1190000006158186)

**垂直拆分**

根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表

- 垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

### 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。


水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。

水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。