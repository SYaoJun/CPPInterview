# 数据库概论
- 索引
- 事务
- 锁
- 并发控制
- 存储
- 副本
- 恢复
- 调优
## 索引
### 什么是索引
- 索引是数据表中对字段进行排序的一种数据结构。常用的索引有
1. B+
2. AVL 
3. Hash
4. RBtree
- 哈希表不利于范围查找。
- 红黑树在数据量大的时候性能会下降。

### 联合索引
- 对多个字段同时建立的索引。Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分，**跳跃索引查询**就会导致索引失效。
### 唯一索引
### 覆盖索引
### 最左匹配原则
## B+树
1.  具有n个关键字的节点含有n个分支。而在B树中，具有n个关键字的节点含有n+1个节点。
2.  B+树的叶子节点包含了所有关键字，并且包含信息。
3.  B+树非叶子节点只起索引作用，不存数据。
4.  B+数在叶子节点使用指针将前后磁盘块中的索引连接起来，形成一个线性链表，方便范围查询。


## B树和B+树的区别

1.  B树：叶节点具有相同的深度，**所有索引元素不重复**，节点中的数据索引从左到右递增排列。
2.  B+树：**非叶子节点不存储数据，只存储索引**，叶子节点包含了全部的关键字且存储数据。叶子节点用指针连接从左往右递增排序，提高区间访问的性能。


## 数据库三大范式

1.  数据库中的**所有字段**都是**不可分割的原子值**
2.  满足第一范式的前提下，除主键外的**每一列**都必须**完全依赖于主键**。如果不完全依赖，只能发生在联合主键下。
3.  满足第二范式的前提下，除开主键列的其他**列之间**不能有**传递依赖**关系。
## 事务
### 事务的特性
1. 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
3. 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
4. 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
### 隔离级别
1. READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
2. READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
3. REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生
4. SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读

### 不同隔离级别存在的问题
1. 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
2. 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失
3. 不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读
4. 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
 
### 左右联接

- inner join： 只保留两表完全匹配的结果集
- left join: 返回左表所有的行，右表中没有返回为null
- full join: 全外联接 ，返回左表和右表中所有没有匹配的行。mysql不支持 full join，使用left join union right join来实现。

### 主键

主键：**唯一且非空。**一个表有且只能由一个主键约束。创建主键会自动创建对应的索引，同样删除主键，对应的索引也会被删除。
### 外键
外键约束：如果定义了外键约束，主表中没有的数据在子表中是**不可以被使用的**。主表中的记录被子表引用，是不可以被删除的。


### 查询

分组查询：count() sum() max() min() avg()

聚合查询：7种 A B A∪B A∩B   A - A∩B  B - A∩B  A∪B - A∩B

左连接： A - A∩B   右连接：B - A∩B  内连接：A∩B

## 悲观锁和乐观锁

1.  悲观锁： **每次去拿数据时都认为别人会修改，所以每次在拿数据的时候都会上锁。悲观锁由数据库自己实现，共享锁和排他锁是悲观锁的不同实现。悲观锁的缺点：效率低，并行差，增加死锁的概率。**
2.  乐观锁：**每次去拿数据都认为别人不会修改，所以不会上锁。乐观锁适用于读多，写少的场景。乐观锁常见的实现方式：版本号机制和CAS自旋算法。乐观锁的缺点：ABA问题，循环时间长开销大，只能保证一个共享变量的原子操作。**

## 调优
### 什么时候应该创建索引

1.  频繁查询字段

### 什么时候不应该创建索引

1.  where条件里用不到的字段
2.  频繁更新的字段
3.  表记录太少<300W
4.  重复且平均的表字段

### explain 查看执行计划

使用explain关键字可以**模拟优化器执行sql查询语句**，从而知道mysql是如何处理sql语句的。分析查询语句或表结构的性能瓶颈。


### show profile

用来分析当前会话中**语句执行的资源消耗情况。**

### 分库分表
[MySQL大表优化方案](https://segmentfault.com/a/1190000006158186)

**垂直拆分**

根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表

- 垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

### 水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。


水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。

水平拆分能够 支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。
## 聚簇索引

- 聚簇索引的叶子节点都是数据节点。
- 非聚簇索引的叶子节点让然是索引节点，有指向对应数据块的指针。

## MySQL优化

- explain
    - extra中显示filesort进行了文件排序，提示建立索引。
    - using index condition使用了索引但是，进行了回表查询。
- show profile
- SQL语句优化
    - 模糊查询like%
    - 避免使用select *
    - insert尽量使用批量查询
    - 字符串单引号
    - left join对右边的数据建立索引
    - 范围查询右边的列索引失效
    - 不等号全表查询
    - is null或者is not null都无法使用索引

## binlog

[链接](https://blog.csdn.net/eagle89/article/details/107959587?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)

- 以二进制的形式记录了数据库的变更操作。
- binlog有三种格式
    - statement记录SQL
    - reow记录实际变更
    - mixed混合
- 主要流程
    - **slave订阅了master的binlog**，通过slave的IO线程和master的dump线程通信，同步binlog。
    - IO线程读取到binlog后悔写入到relay log中准备重放。
    - **slave通过SQL线程读取到relay log重新执行响应的操作。**
- 主从复制不是强一致性，而是最终一致性。
- master配合binlog会影响性能。

## redo log

- 记录数据的逻辑修改。
    - 更新buffer  pool页里面的数据
    - 生成一个redo log对象
    - commit后，持久化这个redo log对象到磁盘
- 出于事务的考虑以及顺序IO比随机IO效率更高。
- 当达到checkPoint后，即log满了以后，就将数据更新到磁盘上。
- redo log有两个文件，循环写入。

## undo log

- 记录事务的回滚
- 多版本并发控制
    - 行id
    - 事务id
    - 回滚指针

## read view

- 快照读时产生的读视图
    - 在RC，每个快照读都生成最新的read view
    - **在RR，同一事务在第一个快照读时创建read view    **
    - RC读提交，可以读到最新的commit。
    - RR可重复读，读的是快照版。

## 分表

- 垂直分表：将表按照功能模块划分。
    - 商品表
    - 支付表
    - 用户表
    - 日志表
- 水平分表：根据userID散列到不同的库中。
    - userID % 2 == 0
    - userID % 2 == 1

## 读未提交

- A事务读到了B事务未提交的数据

## 读已提交

- **A事务提交之后，它做的变更才会被其他事务看到。**可以解决脏读问题。A事务可以读取到B事务已经提交的数据。

## 可重复读

- 一个事务在执行过程中所看到的数据，总是跟这个事务在**启动时看到的数据是一致的**，可以解决脏读和不可重复读。

## 串行化

- 加读写锁，锁冲突时串行执行。

## InnoDB默认隔离级别

- 可重复读RR

## 并发控制

- LBCC：解决当前读下的幻读问题。
- **MVCC：解决快照读下的幻读问题。**

## 行锁

- 记录锁record lock
- 间隙锁gap lock
- 临键锁next-key lock

## 当前读

- 读取数据的最新版本，同时加锁，使用的是**临键锁**。

## 快照读

- 读取数据的历史版本。

## MVCC

- 通过版本号，避免同一数据在不同事务见的竞争，主要是提高数据库的并发读写性能，不用加锁就能让多个事务并发读写。
- MVCC的实现依赖于：**三个隐藏字段，undo log和read view**
- 核心思想：**只能查找事务id小于等于当前事务id的行。**

## 三个隐藏字段

- DB_TRX_ID：事务id
- DB_ROLL_PTR：回滚指针
- DB_ROW_id：行标识

## undo log

- 每当我们对一条记录做改动insert/delete/update时，都需要把以后回滚的东西记录下来。
- 总之，InnoDB把为了回滚而记录的东西称为undo log
- **undo log是逻辑日志**
- 所有的改动形成一个版本链，版本链的头节点就是当前记录的最新的值。
- undo log删除时机：没有比这个undo log更早的read view时，undo log就会被删除。

## read view

- 就是进行快照读时生产的一致性读视图。

## 隔离级别引起的并发问题

- 不可重复读：B事务读取到了A事务已经提交的数据，数据内容不一致。
- 幻读：B事务读取到了A事务已经提交的数据，数据数量不一致。

## 什么是索引

- 是一种加速查询和排序的数据结构。

## SQL优化

- **对where和order by的列建立索引**
- 避免在where子句中对空值进行不等于判断
- 避免在where子句中使用or连接，否则会使引擎放弃索引而进行全表扫描
- **少用in和not in**
- **少用like查询**
- 避免在where中使用函数操作
- **不要使用select ***
- 尽量避免大事务操作
- **join字段提前加上索引**

## 快照读和当前读

- 快照读：**读取的是记录数据的可见版本，可能是过期的数据，不用加锁。**只要当前事务还未提交，读取的数据就是可见版本，不会受其他事务提交与否的影响。快照是在你开启事务后，第一次用select时生成的。
- 当前读：**读取的是记录数据的最新版本，并且当前读返回的数据会加上锁**，保证其他的事务不会再并发地修改这条记录。
- select 是快照读
- **update insert delete 是当前读**
- MVCC不能从根本上解决幻读
- **快照读是通过undo log + MVCC 来实现的**

## redo log和undo log的区别

- redo log提供前滚操作。通常是物理日志，记录的是数据页的物理修改。
- **undo log提供回滚操作。通常是逻辑日志，回滚行记录到某个版本。**

## 平衡树和红黑树的区别

- **平衡树是严格的左右子树高度差不超过1**
- 红黑树在平衡性上做了妥协，自定义了四条规则
    - 所有的根节点都是黑色
    - 红色的孩子是黑色
    - 任意节点到叶子节点的路径上黑色节点的数目相同
    - 所有叶子节点都是黑色
- **红黑树牺牲查找的效率，换取了插入和删除的效率，但是平均时间复杂度还是logn**

## 聚集索引

- 索引和数据没有分离。

## 共享锁和排它锁

[行锁和表锁讲解](https://www.bilibili.com/video/BV1AE411a7rv?from=search&seid=6023900352334983316)

- 行锁和表锁是粒度概念，共享锁和排它锁是具体实现。
- 共享锁：**读锁**  能读不能写
- 排它锁：**写锁  **不能读也不能写
- **表锁**
    - 意向锁
    - 自增锁
- **行锁**
    - record lock
    - gap lock
    - next-key lock
- **无锁**

```sql
select * from user; 
```

- **共享锁**

```sql
select ... lock in share mode;
select ... for share;  MySQL 8.0
```

- **排它锁**

```sql
update ...
delete ...
insert ...
select ... for update
```

- **注意**
    - **某个事务获取数据的排它锁，其他事务不能获取该数据的任何锁，并不代表其他事务不能无锁读取该数据。**
    - 简单来说：**加了排它锁的数据，其他事务还可以用无锁读取数据。**

### 隔离级别

- 读未提交  有脏读的问题  A的数据未提交就被B读到了
- 读提交  解决了脏读 可能产生不可重复读  两次读取的结果不一致
- 可重复读  解决了不可重复读   可能产生幻读 幻读就是B提交事务以后，A查看自己开启事务中的数据，没有更新，但是插入对应的数据就报错说重复插入了。
- 串行化 解决幻读

## 事务

- 一组操作，要么同时成功，要么同时失败。

## 事务特性

- 原子性：事务是不可分割的。
- 一致性：事务操作前后的总量保持不变。
- 隔离性：事务操作间应该互不影响。
- 持久性：事务提交后改变是永久的。

### Mysql分库分表

读写分离：解决高并发。
分库分表：解决高可用。
分库：减少并发问题
分表：降低了分布式事务

垂直分表：一个表，列比较多，把不同的字段分到不同的表中，降低单表大小来提高性能。
水平分表：以某个字段按照一定的规则，将一个表的数据分到多个表中。特点是表结构一样。
分表策略

- hash取模

- range范围区分

- list预定义

### 左右联接

[学习视频](https://www.bilibili.com/video/BV1Vt411z7wy?p=55)

- inner join： 只保留两表完全匹配的结果集。

- left join: 返回左表所有的行，右表中没有返回为null

- full join: 全外联接 ，返回左表和右表中所有没有匹配的行。mysql不支持 full join，使用left join union right join来实现。


联接练习题

- 组合两个表

- 部门工资最高的员工

- 从不订购的客户


alter table 表名 alter column 字段名 set default 默认值;

### 隔离级别

- 读未提交【脏读】

- 读提交 【不可重复读】

- 可重复读【幻读】

- 串行化

### 事务特性

- 原子性：事务是不可分割的。

- 一致性：事务操作前后总量不变。

- 隔离性：事物之间不产生影响

- 持久性：一旦提交事务，改变是永久的。


开启事务

- set autocommit = 0

- begin

- start transaction

### 关键字

- group by 分组

- having作用于组

- order by对某一列进行排序

- where后不能有聚合

- limit row: offset

- 7个关键字执行顺序：
    - from

    - where

    - group by

    - having

    - select

    - order by

    - limit

### 数据库优化

- explain执行计划

- limit优化

- 性能监控show profile

### Mysql主从复制和读写分离

提高数据库的并发性能。
一个master负责写操作，两台slave负责读操作。
**主从复制的原理master-slave**

- 当主库进行增删改操作时，会按顺序写入到binlog中。

- **每个从库创建binlog dump线程连接到主库。**

- 当master节点的binlog有变化时，**binlog dump线程会通知所有slave节点**，并将相应的binlog内容推送给slave节点。

- slave的IO线程收到binlog内容后，将内容写入到本地的relay-log

- **sql线程读取本地的relay-log重新在从库中复现主库的增删改的操作。**


读写分离存在的问题：

- 数据不一致问题


## 分库分表

数据库的IO瓶颈和CPU瓶颈都会导致数据库活跃连接数增加，进而逼近数据库可承载连接数的最大值。
IO瓶颈：磁盘读IO瓶颈，**热点数据太多，数据库缓存放不下**，每次查询时产生大量的IO，降低查询数据。解决方案【分库和垂直分表】


CPU瓶颈：SQL问题，包含join，group by，order by，非索引字段查询等，增加CPU运算的操作。解决方案【**SQL优化，建立适当的索引，在业务Service层进行业务计算**】单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈。解决方案【水平分表】

分库分表工具：

- mycat

- sharding-sphere

- TDDL


分库分表总结：

- 分库分表首先要知道瓶颈在哪儿，才能合理地拆分。

- 选key很重要，既要考虑到拆分均匀，也要考虑到非patition key的查询。

## 锁机制

- 页锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- 行锁：InnoDB支持默认行锁，也支持表锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 表锁：MyISAM支持表锁。开销小，加锁快；不会出现死锁；锁的粒度大，发生锁冲突的概率最高,并发度最低。

另一种分类方式

- 悲观锁：共享锁（读锁），排他锁（写锁）。
- 乐观锁：通过version控制

行锁分为三级，粒度从小到大依次是

- **记录锁**（Record Lock）：单行
- 间隔锁（Gap Lock）：一个开区间内的多行
- 防插入锁（Next-Key Lock）：一个前开后闭区间内的多行，实际上是记录锁和间隔锁的结合