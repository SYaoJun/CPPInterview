# Java Virtual Machine
- Java虚拟机
### Java内存结构

分为五个部分：
1. 程序计数器（线程私有）
2. 虚拟机栈（线程私有）
3. 本地方法栈（线程私有）
4. 堆
5. 方法区

- 程序计数器：用于记录下一条指令的地址。
- 虚拟机栈：线程运行时需要的内存。
- 本地方法栈：运行非Java语言时需要的内存。
- 堆：所有new出来的对象存储的地方。
- 方法区：是一个逻辑概念，jdk1.8以后放在metaspace元空间中。

###  垃圾回收算法

- 标记清除mark-sweep
- 标记整理mark-compact
- 复制copying

新生代：使用复制算法

老年代：标记整理

CMS： 标记清除，专门用于老年代，可以同时进行垃圾回收和其他任务。



### JVM调优

-   主要是为了减少Full GC的次数
-   主要调节非标准参数-XX开头的参数，比如-Xms堆内存初始化大小，-Xmx堆内存最大大小
-   Java程序运行时显示jvm参数fprintflagfinal
-   查看Java进程的jvm参数jinfo -flags 进程ID



### 双亲委派机制

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

类加载器的类别：

- 启动类加载器BootstrapClassLoader(C++编写) rt.jar
- 扩展类加载器ExtClassLoader jre/lib/ext
- 系统类加载器AppClassLoader classpath
- 自定义加载器CustomClassLoader



如果都没加载成功，抛出异常**Class Not Found**

作用：

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。



### Java内存模型

Java memory model = JMM

其实Java线程内存模型，是基于cpu缓存模型建立起来的。

线程有独占的工作内存，是共享内存的副本拷贝。

violate保证多个线程之间变量的可见性。

数据原子操作。read/write/load/store/assign/use/lock/unlock

Java内存模型：定义了一套在多线程读写共享数据时，对数据的可见性，有序性和原子性的规则和保障。



### 垃圾回收器★★

1. serial 串行GC
2. PS 并行GC **jdk1.8默认**
3. CMS 并行执行垃圾回收同时不阻塞应用程序(STW=200ms)
4. G1(STW=10ms)  **jdk1.9默认**
5. ZGC(STW=1ms)



### 哪些对象可以作为GCroot

- 在虚拟机栈中引用对象

- 在方法区中常量引用的对象

- 在本地方法栈中JNI引用的对象

- Java虚拟机内部的引用

- 所有被同步锁（synchronized关键字）持有的对象



### 新生代的对象什么时候会进入老年代

-   当新生代年龄超过了设定值，会进入老年代。

-   新生代空间装不下了，会进入老年代。

    新生代：老年代 = 1 : 2

    Eden：From：To = 8 : 1 : 1



### 如何判断对象是否可以回收

1. 引用计数(循环引用问题)
2. 可达性分析

Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。

扫描堆中的对象，看是否能够沿着gc root对象为起点的引用链找到该对象，找不到，表示不可回收。

