# Redis
- C语言编写的基于内存可持久化的key-value内存数据库。
## 理论篇
### 参考视频
- [黑马程序员2022Redis](https://www.bilibili.com/video/BV1cr4y1671t?p=99&vd_source=e9f1ced96b267a4bc02ec41ca31d850a)
### Redis的优点
- 数据结构丰富
- 持久化
- 支持事务
- 分布式锁
- 支持主从复制
- 读写性能优异
### Redis的缺点
- 数据库容量受物理内存的限制
- 不能用作海量数据的高性能读写
### 单线程的好处
- 避免多线程的竞争条件和上下文切换，不用考虑各种锁的问题
- 使用IO多路复用，非阻塞IO
### 数据类型
1. string
2. list
3. set
4. hash
5. zset
### 字符串
- Redis使用SDS(simple dynamic string)简单动态字符串作为字符串表示
- 常数复杂度获取字符串长度。
- 杜绝缓冲区溢出。
- 减少修改字符串长度时所需的内存重分配次数。
- 二进制安全。
- 兼容部分C字符串函数
- Redis的字典使用哈希表作为底层实现
- Redis使用跳表作为有序集合键的底层实现之一
- Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构

### 过期删除机制
1. 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
2. 惰性删除：查询的时候再删。

## 内存淘汰机制
1. volatile-lru
2. volatile-ttl
3. volatile-random
4. allkeys-lru
5. allkeys-random
6. no-eviction

### 持久化
1. RDB快照（默认）
2. AOF日志追加
- RDB是一个经过压缩的二进制文件，SAVE命令阻塞服务器去保存，BGSAVE不阻塞服务器，而是由子进程进行保存，可以设置定期保存的条件。RDB文件记录的是当前状态有哪些数据。
- AOF记录的是操作的命令。AOF和RDB同时开启时，AOF优先级更高。AOF恢复时需要重新执行命令，比较耗时，因此提供了AOF重写操作。
- Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。


### RDB的优缺点
- 优点：适合大规模的数据恢复，对数据的完整性要求不高。
  1. 性能好。fork子进程来完成写操作。
  2. 恢复快。直接解析RDB二进制文件。
- 缺点：最后一次持久化的数据可能丢失，fork子进程占用内存空间。
- 有数据丢失的风险。
- 主程序有大量写入操作时，会触发copy on write，此时父子进程各持有独立的一份数据，大量写入会产生大量的分页错误。

- 触发持久化的机制
1. sava配置中的条件
2. flushall
3. 退出redis
- 恢复dump.rdb文件，只需将rdb文件放入redis启动目录下

### AOF的优缺点
- AOF日志模式：将所有命令都记录下来，恢复的时候把这个文件全部再执行一遍。
- 默认是不开启的，手动开启`appendonly yes`
- 默认每秒修改存储一次，重启后生效。
- 修复aof文件`redis-check-aof --fix appendonly.aof`
- 优点：每次修改都同步，文件的完整性更好。每秒同步一次，可能会丢失一秒的数据。
- 数据安全，无丢失。
- 缺点：aof文件大小远远大于rdb,修复速度也比rdb慢。启动效率低。

### 缓存雪崩（redis宕机）
1. 缓存集中同时失效
2. 大量不同请求打到数据库
- 缓存同一时间大面积的失效，所以后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
- 缓存雪崩：是指在某一时间段，缓存集中过期失效，redis宕机/断网。
- 解决方案：搭建集群，限流降级，数据预热（把可能访问的数据预先加载到缓存）。
- 解决办法：
  1. 事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上。
  2. 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
  3. 事后：利用redis持久化机制保存的数据尽快恢复缓存
  ### 缓存穿透（缓存没有，恶意）
  1. 不存在的数据
  2. 大量同一个请求打到数据库
  - 一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
  - 解决方案：
    1. 布隆过滤器
    2. 缓存空对象
  - 解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

### 缓存击穿（缓存有）
1. 缓存过期
2. 大量同一（热点）请求打到数据库

- 缓存击穿(量太大，缓存过期)：高并发的热点key在过期的瞬间，持续的高并发直接请求数据库。
- 解决方案：设置热点数据永不过期，加互斥锁，设二级缓存，保证过期时间不集中。
- 使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

### 数据一致性
- 缓存和数据库之间要保证一致性要强调两点前提：
  1. 缓存必须要有过期时间
  2. 保证缓存和数据的最终一致性，强一致性不容易做到

为什么需要有过期时间？

首先对于缓存来说，当它的命中率越高的时候，我们的系统性能也就越好。如果某个缓存项没有过期时间，而它命中的概率又很低，这就是在浪费缓存的空间。而如果有了过期时间，且在某个缓存项经常被命中的情况下，我们可以在每次命中的时候都刷新一下它的过期时间，这样也就保证了热点数据会一直在缓存中存在，从而保证了缓存的命中率，提高了系统的性能。

设置过期时间还有一个好处，就是当数据库跟缓存出现数据不一致的情况时，这个可以作为一个最后的兜底手段。也就是说，当数据确实出现不一致的情况时，过期时间可以保证只有在出现不一致的时间点到缓存过期这段时间之内，数据库跟缓存的数据是不一致的，因此也保证了数据的最终一致性

为什么不追求强一致性？

这个主要是个权衡的问题。数据库跟缓存，以Mysql跟Redis举例，毕竟是两套系统，如果要保证强一致性，一般都要引入分布式一致性协议或者分布式锁等等，一是实现上有一定的难度，增加系统的复杂性，对性能会有一定的影响，如果真的需要强一致性，缓存这一层的必要性有待具体分析

DB和缓存的读写顺序

经典的[Cache-Aside pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside)，这个方案的思路是：

1. 失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中
2. 命中：程序先从缓存中读取数据，如果命中，则直接返回
3. 更新：程序先更新数据库，再删除缓存

一般对于1和2两步中需要考虑的细节较少，主要是第三步的更新，如何确保更新的时候仍然可以确保缓存数据的一致性

一共有四种可能

1. 先更新缓存，再更新数据库
2. 先更新数据库，再更新缓存
3. 先删除缓存，再更新数据库
4. 先更新数据库，再删除缓存

1、先更新缓存，再更新数据库
不管是操作数据库还是操作缓存，都有失败的可能。如果我们先更新缓存，再更新数据库，假设更新数据库失败了，那数据库中就存的是老数据。当然你可以选择重试更新数据库，那么再极端点，负责更新数据库的机器也宕机了，那么数据库中的数据将一直得不到更新，并且当缓存失效之后，其他机器再从数据库中读到的数据是老数据，然后再放到缓存中，这就导致先前的更新操作被丢失了，因此这么做的隐患是很大的

从数据持久化的角度来说，数据库当然要比缓存做的好，我们也应当以数据库中的数据为主，所以需要更新数据的时候我们应当首先更新数据库，而不是缓存

**2. 先更新数据库，再更新缓存**

主要有两个问题，首先是并发的问题：假设线程A（或者机器A，道理是一样的）和线程B需要更新同一个数据，A先于B但时间间隔很短，那么就有可能会出现：

1. 线程A更新了数据库
2. 线程B更新了数据库
3. 线程B更新了缓存
4. 线程A更新了缓存

按理说线程B应该最后更新缓存，但是可能因为网络等原因，导致线程B先于线程A对缓存进行了更新，这就导致缓存中的数据不是最新的。

第二个问题是，我们不确定要更新的这个缓存项是否会被经常读取，假设每次更新数据库都会导致缓存的更新，有可能数据还没有被读取过就已经再次更新了，这就造成了缓存空间的浪费。另外，缓存中的值可能是经过一系列计算的，而并不是直接跟数据库中的数据对应的，频繁更新缓存会导致大量无效的计算，造成机器性能的浪费

这种方案不可取，应当考虑删除缓存

**3. 先删除缓存，再更新数据库**
这个方案的问题也是很明显的，假设现在有两个请求，一个是写请求A，一个是读请求B，那么可能出现如下的执行序列：

1. 请求A删除缓存
2. 请求B读取缓存，发现不存在，从数据库中读取到旧值
3. 请求A将新值写入数据库
4. 请求B将旧值写入缓存

这样就会导致缓存中存的还是旧值，在缓存过期之前都无法读到新值。这个问题在数据库读写分离的情况下会更明显，因为主从同步需要时间，请求B获取到的数据很可能还是旧值，那么写入缓存中的也会是旧值

**4. 先更新数据库，再删除缓存**

这种方式是最常用的，但并不代表没有任何问题。
依然假设有两个请求，请求A是查询请求，请求B是更新请求，那么可能会出现下述情形

1. 先前缓存刚好失效
2. 请求A查数据库，得到旧值
3. 请求B更新数据库
4. 请求B删除缓存
5. 请求A将旧值写入缓存

上述情况确实有可能出现，但是出现的概率可能不高，因为上述情形成立的条件是在读取数据时，缓存刚好失效，并且此时正好又有一个并发的写请求。考虑到数据库上的写操作一般都会比读操作要慢，（这里指的是在写数据库时，数据库一般都会上锁，而普通的查询语句是不会上锁的。当然，复杂的查询语句除外，但是这种语句的占比不会太高）并且联系常见的数据库读写分离的架构，可以合理认为在现实生活中，读请求的比例要远高于写请求，因此我们可以得出结论。这种情况下缓存中存在脏数据的可能性是不高的

那如果是读写分离的场景下，按照如下所述的执行序列，一样会出问题：

1. 请求A更新主库
2. 请求A删除缓存
3. 请求B查询缓存，没有命中，查询从库得到旧值
4. 从库同步完毕
5. 请求B将旧值写入缓存

如果数据库主从同步比较慢的话，同样会出现数据不一致的问题。事实上就是如此，毕竟我们操作的是两个系统，在高并发的场景下，我们很难去保证多个请求之间的执行顺序，或者就算做到了，也可能会在性能上付出极大的代价

那为什么我们应当先更新数据库呢？因为缓存在数据持久化这方面往往没有数据库做得好，而且数据库中的数据是不存在过期这个概念的，我们应当以数据库中的数据为主，缓存因为有着过期时间这一概念，最终一定会跟数据库保持一致。

**还有没其他办法**

1. 引入消息队列，将删除缓存的操作作为一条消息，放入消息队列
2. 订阅Binlog，比如DataBus来监控Binlog，一旦数据发生变更，Binlog消息通知回来去删除缓存

- 删缓存有可能出现缓存击穿问题怎么解决
采用删除缓存的方案，在高并发场景下可能会导致缓存击穿（这个跟缓存穿透还有点区别），也就是大量的请求同时去查询同一个缓存，但是这个缓存又刚好过期或者被删除了，那么所有的请求全部都会打到数据库上，导致严重的性能问题。

当一个线程需要去访问这个缓存的时候，如果发现缓存为空，则需要先去竞争一个锁，如果成功则进行正常的数据库读取和写入缓存这一操作，然后再释放锁，否则就等待一段时间之后，重新尝试读取缓存，如果还没有数据就继续去竞争锁。这个是单机场景

如果有多台机器同时去访问同一个缓存项该怎么办呢？如果机器数不是很多的话，这种情况一般来说也不会成为一个问题，不过这里有个优化点，就是从数据库读取到数据之后，再对缓存做一次判断，如果缓存中已经存在数据，就不需要再写一遍缓存了。但是如果机器数也很多的话，那么就得考虑上分布式锁了

但是需要强调锁的代价，分布式锁对性能有影响，不能盲目上分布式锁，系统越简单越好

**需要强一致性怎么做**

对缓存增加分布式读写锁，读写锁的特性可以多读，但是只能单写，利用读写锁，可以保证读请求不会读取到旧数据，但是写的过程所有读请求都会被阻塞，这个问题再高并发的情况下有可能把会服务器的请求线程池打满

这里用到的分布式读写锁并没有解决缓存击穿的问题，因为从读请求的视角来看，如果发生了更新数据库的情况，读请求要么被阻塞，要么就是缓存为空，需要从数据库读取数据再写入缓存。为了防止因缓存失效或被删除导致大量请求直接打到数据库上导致数据库崩溃
### 数据更新
- 先更新数据，再删除缓存，依然有潜在的并发问题。


## 实践篇
### 启动
brew services start redis 启动并前台运行
brew services stop redis 停止服务
redis-server /usr/local/etc/redis.conf 启动并后台运行
mysql -uroot 本地登录
brew services start mysql 前台
mysql.server start 后台
### string

- string的底层采用简单动态字符串SDS。

```shell
set name longwang
get name
mset age 20 address shanghai
```

### hash

- hash底层实现为一个字典dict。
- 当数据量比较小或者单个元素比较小时，底层用ziplist存储。

```shell
hset user name chuangwang
hget user name
hmset user age 20 address shanghai
hmget user age address
hgetall user
hdel user age address
```

### list

- list的底层实现采用quicklist和ziplist。
- quicklist是双向链表。
- ziplist是一种更紧凑，更节省内存空间的链表。

```shell
lpush students longwang haoge
rpush students bingge
lrange students 0 -1 查看全部
llen 查看长度
lrem student 1 haoge //移除左边的
```

### set

- set为无序的，自动去重的数据类型。
- set底层为一个value为null的字典dict。

```shell
sadd letters aaa bbb ccc ddd
scard letters
srem letters aaa 移除
```

### zset

- zset有序，自动去重的数据类型。
- zset底层实现为字典dict+跳表skiplist。
- 当数据比较少时，用ziplist存储。

```shell
zadd users 10 zhangsan 8 lisi
zcard users 总数量
zrange users 0 5 查看
zrem users zhangsan 移除
```

### 失效时间

```shell
set code test ex 30 秒
set code test px 30000 毫秒
ttl code 查看剩余失效时间 -1代表永不失效
expire code 20 分批次设置失效20秒后
pttl code 查看剩余失效毫秒
set code test nx 不存在时设置成功
set code test xx 存在时设置成功
```
## redis事务
- 监控字段watch
- 开启事务multi
- 命令入队
- 执行事务exec
- redis单条命令是保证原子性的，但是redis的事务是不保证原子性。
redis事务没有隔离级别的概念，一个事务的所有命令都会被序列化，在事务执行过程中，按照顺序执行。所有的命令在事务中，并没有直接执行，只有发起执行命令的时候才执行，Exec。

**必须在事务开启之前watch，也就是不能再事务中间开启监控。**
对key添加监视锁watch
分布式锁
setnx lock_key value
使用setnx设置一个公共锁，利用setnx命令的返回值特征，**有值则返回设置失败0，无值则返回设置成功1。**

- 成功。拥有控制权，执行下一步业务，用完后del释放锁。

- 失败。不具有控制权，排队等待。


**如果释放锁之前宕机，就会导致死锁，可以设置锁的过期时间来解决。**
**set num 666 nx ex 100**
误删锁问题：如何得知获取的锁是否是自己的锁。**设置锁的名字，删除之前先对比。**
重入性问题：获取锁之后，执行代码的过程中，尝试再次获取锁。记录锁的名称，比较一下，如果相同就继续让执行，再释放锁时记录调用层数，在最外层释放锁。使用hash来实现。
hset user name jack
hset user age 21
**取消或放弃事务discard**
一旦事务执行成功后，监控自动取消掉。如果想手动关闭监控使用unwatch。
exec返回nil表示事务执行失败
redis可以实现乐观锁
乐观锁：不加锁，更新数据时才去判断，获取version，然后比较version，监控某个值，执行事务之前，另一个线程修改了这个值，就会导致事务执行失败。
悲观锁：总是加锁。
事务执行中的错误：

- 语法错误：exec时，所有事务都不会执行。

- 运行时错误：比如对一个字符串自增，incr str 其他事务正常执行，只有出错的命令执行失败。

## 面试篇
### 考点
- 五种基本数据结构
- 三种特殊数据类型：geo/hyperloglog/bitmap
- 持久化
- 事务
- 过期删除策略
- 内存淘汰策略
- 集群
- 哨兵
- 缓存穿透
- 缓存击穿
- 缓存雪崩
- 分布式锁
### 常见问题
1. redis可以用作集群吗？集群中数据同步是怎么实现的？分布式事务是怎么实现的？
2. 分布式事务的实现方式有哪些？
3. redis支持多线程吗？并发控制是怎么解决的？
4. redis支持分布式吗？支持多集群吗？
